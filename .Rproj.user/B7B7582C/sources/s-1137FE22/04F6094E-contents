update_predictions <- function(labelled, unlabelled, plot = FALSE) {
  
  defaultW <- getOption("warn")

  
  # Transform impact speed to common range [0, 1].
  maximpact0 <- labelled %>% 
    group_by(caseID) %>% 
    summarise(maximpact0 = max(impact_speed0, na.rm = TRUE), .groups = "keep") %>% 
    ungroup() %>% 
    dplyr::select(caseID, maximpact0)
  
  labelled %<>% 
    left_join(maximpact0, by = "caseID") %>% 
    mutate(impact_speed0 = impact_speed0 / maximpact0,
           impact_speed1 = impact_speed1 / maximpact0)

  
  # Labelled, wide to long format.
  labelled0 <- labelled %>% 
    dplyr::select(caseID, eoff, acc, eoff_acc_prob, final_weight, impact_speed0) %>% 
    mutate(scenario = 0) %>% 
    dplyr::rename("impact_speed" = impact_speed0)
  
  labelled1 <- labelled %>% 
    dplyr::select(caseID, eoff, acc, eoff_acc_prob, final_weight, impact_speed1) %>% 
    mutate(scenario = 1) %>% 
    dplyr::rename("impact_speed" = impact_speed1)
  
  labelled <- labelled0 %>% 
    add_row(labelled1) %>% 
    left_join(maximpact0, by = "caseID") %>% 
    mutate(caseID = factor(caseID, labels = paste0("caseID", sort(unique(caseID)))))
  
  
  # Unlabelled, wide to long format.
  unlabelled0 <- unlabelled %>% 
    dplyr::select(caseID, eoff, acc, eoff_acc_prob, crash0, non_crash0, max_impact0) %>% 
    mutate(scenario = 0) %>% 
    dplyr::rename("crash" = crash0,
                  "non_crash" = non_crash0,
                  "max_impact" = max_impact0)
  
  unlabelled1 <- unlabelled %>% 
    dplyr::select(caseID, eoff, acc, eoff_acc_prob, crash1, non_crash1, max_impact1) %>% 
    mutate(scenario = 1) %>% 
    dplyr::rename("crash" = crash1,
                  "non_crash" = non_crash1,
                  "max_impact" = max_impact1)
  
  unlabelled <- unlabelled0 %>% 
    add_row(unlabelled1) %>% 
    left_join(maximpact0, by = "caseID") %>% 
    mutate(caseID = factor(caseID, labels = paste0("caseID", sort(unique(caseID)))))
  
  
  crash <- unlabelled$crash
  non_crash <- unlabelled$non_crash
  max_impact <- unlabelled$max_impact
  ymin <- min(labelled$impact_speed)
  ymax <- 1
  
 
  # Prepare data for model fitting with LASSO.
  form <- ~ -1 + scenario + eoff + log(0.1 + eoff) + acc + log(-acc) + 
    caseID*scenario*eoff*acc + caseID*scenario*log(0.1 + eoff)*log(-acc)
  X <- model.matrix(form, data = labelled)
  newX <- model.matrix(form, data = unlabelled)
  ntrain <- nrow(X)
  ix <- sample(1:ntrain) # Scramble training data.
  y <- labelled$impact_speed[ix]
  X <- X[ix, ]
  
  
  # Estimate impact speed. ----
    
  # Random forest.
  options(warn = -1)
  rf <- safe_caret_train(log(impact_speed) ~ scenario + caseID + eoff + acc, 
                         data = labelled %>% filter(impact_speed > 0 & impact_speed < ymax),
                         method = "ranger",
                         num.trees = 100,
                         tuneLength = 3,
                         trControl = trainControl(method = "cv",
                                                  number = 5,
                                                  search = "random"))
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled data.
    yhat1_train <- exp(predict(rf, labelled))
    yhat1_train[yhat1_train <= 0] <- max(min(yhat1_train[yhat1_train > 0]), 0)
    yhat1_train[yhat1_train > ymax] <- ymax
    
    # Prediction unlabelled data.
    yhat1 <- exp(predict(rf, unlabelled))
    yhat1[yhat1 <= 0] <- max(min(yhat1[yhat1 > 0]), 0)
    yhat1[yhat1 > ymax] <- ymax
    
  } else { # If unable to fit model: use mean of 0 and max impact speed. 

    yhat1_train <- rep(ymax / 2, nrow(labelled))
    yhat1 <- rep(ymax / 2, nrow(unlabelled))
    
  }

  
  # LASSO regression.
  ix <- which(y > 0 & y < ymax)
  nfolds <- ifelse(length(ix) < 10, length(ix), 5)
  
  options(warn = -1)
  lasso <- safe_cv_glmnet(X[ix, ], log(y[ix]), 
                          grouped = FALSE, nfolds = nfolds, 
                          nlambda = 50, maxit = 1e3,
                          penalty.factor = c(0, rep(1, ncol(X) - 1))) # No penalty on main effect of counter-measure.
  options(warn = defaultW)
  
  if ( !is.null(lasso) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled data.
    yhat2_train <- exp(as.numeric(predict(lasso, newx = X, s = "lambda.1se", type = "response")))
    yhat2_train[yhat2_train <= 0] <- max(min(yhat2_train[yhat2_train > 0]), 0)
    yhat2_train[yhat2_train > ymax] <- ymax
    
    # Prediction unlabelled data.
    yhat2 <- exp(as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response")))
    yhat2[yhat2 <= 0] <- max(min(yhat2[yhat2 > 0]), 0)
    yhat2[yhat2 > ymax] <- ymax
    
  } else { # If unable to fit model: use predictions from random forest. 
    
    yhat2_train <- yhat1_train
    yhat2 <- yhat1
    
  }

  
  # Estimate collision probability. ----
  
  # Random forest.
  options(warn = -1)
  sink("msg.txt")
  rf <- safe_caret_train(factor(impact_speed > 0, labels = paste0("Y", 0:1)) ~ scenario + caseID + eoff + acc, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         tuneLength = 3,
                         trControl = trainControl(method = "cv",
                                                  number = 5,
                                                  search = "random",
                                                  classProbs = TRUE))
  sink()
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled data.
    ppos1_train <- predict(rf, labelled, type = "prob")$Y1
    ppos1_train[ppos1_train <= 0] <- min(ppos1_train[ppos1_train > 0])
    
    # Prediction on unlabelled data.
    ppos1 <- predict(rf, unlabelled, type = "prob")$Y1
    ppos1[ppos1 <= 0] <- min(ppos1[ppos1 > 0])
    
  } else { # If unable to fit model: set probabilities manually.
    
    if ( ymax == 0 ) { # If no crashes.
      
      ppos1_train <- rep(0, nrow(labelled))
      ppos1 <- rep(0, nrow(unlabelled))
      
    } else if ( ymin > 0 ) { # If no non-crashes.
      
      ppos1_train <- rep(1, nrow(labelled))
      ppos1 <- rep(1, nrow(unlabelled))
      
    } else {
      
      stop("Error in update_predictions > Estimate collision probability > Random forest >  Unable to fit model. Case not implemented. ")
      
    }
    
  } # End !is.null(rf).

  
  # LASSO logistic regression with outcome-stratified cross-validation. 
  nstrata <- min(min(table(y > 0)), 5)
  events <- which(y > 0) 
  nonevents <- which(!(y > 0)) 
  foldid <- rep(0, length(y))
  foldid[events] <- rep(1:nstrata, length(events))[1:length(events)]
  foldid[nonevents] <- rep(1:nstrata, length(nonevents))[1:length(nonevents)]
  
  options(warn = -1)
  lasso <- safe_cv_glmnet(X, as.factor(y > 0), family = "binomial", 
                          grouped = FALSE, foldid = foldid, 
                          nlambda = 50, maxit = 1e3,
                          penalty.factor = c(0, rep(1, ncol(X) - 1))) # No penalty on main effect of counter-measure.
  options(warn = defaultW)
  
  if ( !is.null(lasso) ) { # If able to fit model: calculate predictions. 
    
    # Prediction on labelled data.
    ppos2_train <- as.numeric(predict(lasso, newx = X, s = "lambda.1se", type = "response"))
    ppos2_train[ppos2_train <= 0] <- min(ppos2_train[ppos2_train > 0])
    
    # Prediction on unlabelled data.
    ppos2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    ppos2[ppos2 <= 0] <- min(ppos2[ppos2 > 0])
    
  } else { # If unable to fit model: use predictions from random forest. 
    
    ppos2_train <- ppos1_train
    ppos2 <- ppos1
    
  } 

  
  # Estimate max impact speed collision probability. ----
 
  # Random forest.
  options(warn = -1)
  sink("msg.txt")
  rf <- safe_caret_train(factor(impact_speed == ymax, labels = paste0("Y", 0:1)) ~ 
                           scenario + caseID + eoff + acc, 
                         data = labelled %>% mutate(ymax = ymax),
                         method = "ranger",
                         num.trees = 100,
                         tuneLength = 3,
                         trControl = trainControl(method = "cv",
                                                  number = 5,
                                                  search = "random",
                                                  classProbs = TRUE))
  sink()
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled data.
    pmax1_train <- predict(rf, labelled, type = "prob")$Y1
    pmax1_train[pmax1_train] <- min(pmax1_train[pmax1_train > 0])
    
    # Prediction on unlabelled data.
    pmax1 <- predict(rf, unlabelled, type = "prob")$Y1
    pmax1[pmax1 <= 0] <- min(pmax1[pmax1 > 0])
    
  } else { # If unable to fit model: set probabilities manually.
    
    if ( ymin == ymax ) { # If all crashes at maximal impact speed.
      
      pmax1_train <- rep(1, nrow(labelled))
      pmax1 <- rep(1, nrow(unlabelled))
      
    } else {
      
      stop("Error in update_predictions > Estimate max impact speed collision probability > Random forest >  Unable to fit model. Case not implemented. ")
      
    }
  }

  
  # LASSO logistic regression with outcome-stratified cross-validation.
  nstrata <- min(min(table(y == ymax)), 5)
  events <- which(y == ymax) 
  nonevents <- which(!(y == ymax)) 
  foldid <- rep(0, length(y))
  foldid[events] <- rep(1:nstrata, length(events))[1:length(events)]
  foldid[nonevents] <- rep(1:nstrata, length(nonevents))[1:length(nonevents)]
  
  options(warn = -1)
  lasso <- safe_cv_glmnet(X, as.factor(y == ymax), family = "binomial", 
                          grouped = FALSE, foldid = foldid, 
                          nlambda = 50, maxit = 1e3,
                          penalty.factor = c(0, rep(1, ncol(X) - 1))) # No penalty on main effect of counter-measure.
  options(warn = defaultW)
  
  if ( !is.null(lasso) ) { # If able to fit model: calculate predictions. 
    
    # Prediction on labelled data.
    pmax2_train <- as.numeric(predict(lasso, newx = X, s = "lambda.1se", type = "response"))
    pmax2_train[pmax2_train <= 0] <- min(pmax2_train[pmax2_train > 0])
    
    # Prediction on unlabelled data.
    pmax2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    pmax2[pmax2 <= 0] <- min(pmax2[pmax2 > 0])
    
  } else { # If unable to fit model: use predictions from random forest. 
    
    pmax2 <- pmax1
    pmax2_train <- pmax1_train
    
  } 

  # Combine predictions on labelled data.
  ppos_train <- (ppos1_train + ppos2_train) / 2
  pmax_train <- (pmax1_train + pmax2_train) / 2
  yhat_train <- (yhat1_train + yhat2_train) / 2
  ypred_train <- labelled$maximpact0 * (ppos_train * yhat_train + pmax_train * (ymax - yhat_train)) # Predicted impact speed.
  ir_pred_train <- (1 + exp(-(-5.35 + 0.11 * ypred_train / 2)))^(-1) # Predicted injury risk.
  labelled$impact_speed <- labelled$impact_speed * labelled$maximpact0 # Observed impact speed.
  labelled$injury_risk <-(1 + exp(-(-5.35 + 0.11 * labelled$impact_speed / 2)))^(-1) # Observed injury risk.
  
  
  # Root mean squared error of predictions on training data.
  w <- with(labelled %>% filter(scenario == 0), final_weight * (impact_speed > 0))
  
  impact_speed_reduction <- with(labelled, impact_speed[scenario == 1] - impact_speed[scenario == 0])
  injury_risk_reduction <- with(labelled, injury_risk[scenario == 1] - injury_risk[scenario == 0])
  impact_speed_reduction_pred <- ypred_train[labelled$scenario == 1] - ypred_train[labelled$scenario == 0]
  injury_risk_reduction_pred <- ir_pred_train[labelled$scenario == 1] - ir_pred_train[labelled$scenario == 0]
  
  log_impact_speed0_sqresid <- with(labelled, (log(impact_speed[scenario == 0]) - log(ypred_train[scenario == 0]))^2)
  impact_speed_reduction_sqresid <- (impact_speed_reduction - impact_speed_reduction_pred)^2
  injury_risk_reduction_pred <- (injury_risk_reduction - injury_risk_reduction_pred)^2
  
  rmse <- list(log_impact_speed0 = sqrt(sum(w * log_impact_speed0_sqresid * is.finite(log_impact_speed0_sqresid), na.rm = TRUE) / sum(w * is.finite(log_impact_speed0_sqresid))),
               impact_speed_reduction = sqrt(sum(w * impact_speed_reduction_sqresid) / sum(w)),
               injury_risk_reduction = sqrt(sum(w * injury_risk_reduction_pred) / sum(w)))
  
               
  # Combine predictions on unlabelled data + add logic.
  ppos <- pmax((ppos1 + ppos2) / 2, crash, na.rm = TRUE) 
  ppos <- ifelse( !is.na(non_crash) & non_crash, rep(0, length(ppos)), ppos)
  pmax <- pmax((pmax1 + pmax2) / 2, max_impact, na.rm = TRUE) 
  pmax <- ifelse( !is.na(non_crash) & non_crash, rep(0, length(pmax)), pmax)
  yhat <- (yhat1 + yhat2) / 2
  ypred <- unlabelled$maximpact0 * (ppos * yhat + pmax * (ymax - yhat))
  
  if ( plot ) {
    plot(unlabelled$eoff, yhat1, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    plot(unlabelled$eoff, yhat2, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    
    plot(unlabelled$eoff, ppos1, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    plot(unlabelled$eoff, ppos2, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    plot(unlabelled$eoff, ppos, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    
    plot(unlabelled$eoff, pmax1, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    plot(unlabelled$eoff, pmax2, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    plot(unlabelled$eoff, pmax, col = unlabelled$scenario + 1, bty = "l", ylim = c(0, 1))
    
    plot(unlabelled$eoff, ypred, col = unlabelled$scenario + 1, bty = "l")
  }
  
  return(list(collision_prob0 = as.numeric(ppos[unlabelled$scenario == 0]), 
              collision_prob1 = as.numeric(ppos[unlabelled$scenario == 1]),
              impact_speed_pred0 = as.numeric(ypred[unlabelled$scenario == 0]),
              impact_speed_pred1 = as.numeric(ypred[unlabelled$scenario == 1]),
              rmse = unlist(rmse)))
  
}
