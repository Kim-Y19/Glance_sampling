# Simulate outcome.
simulate_y <- function(t1, t2, beta = runif(4) * c(1, 0.1, 10, 1), sigma = runif(1, 0, 2), ymin = rbinom(1, 1, 0.15) * runif(1, 0, 5), ymax = runif(1, 20, 50), q = c(runif(1, 0, 0.4), runif(1, 0.85, 1))) {
  
  z <- as.numeric(cbind(t1, t2) %*% beta[1:2] + cbind(log(0.1 + t1), log(0.1 + t2)) %*% beta[3:4]) + rnorm(length(t1), sd = sigma)
  zmin <- quantile(z, min(q))
  zmax <- quantile(z, max(q))
  
  if ( ymin > 0 ) {
    ix <- which(t1 == min(t1) & t2 == min(t2)) 
    zmin <- z[ix]
    z2 <- z
  } else {
    min_ix <- which(z <= zmin)
    z2 <- z
    z2[z <= zmin] <- zmin
    for (i in min_ix) {
      z2[which(t2 <= t2[i] & t1 <= t1[i])] <- zmin
    }
  }
  
  max_ix <- which(z2 >= zmax)
  z3 <- z2
  z3[2 >= zmax] <- zmax
  for (i in max_ix) {
    z3[which(t2 >= t2[i] & t1 >= t1[i])] <- zmax
  }
  z3[length(z3)] <- zmax
  
  y <- ymin + (z3 - zmin) / max(z3 - zmin) * (ymax - ymin)
  
  return(y)
}


# Simulate sample of cases.
simulate_sample <- function(ncases = 10) {
  
  df <- NULL
  for ( i in 1:ncases ) {
    
    dfi <- biv %>%
      mutate(ID = i, 
             y = simulate_y(t1 = after, t2 = before))
    
    df <- df %>% 
      rbind(dfi)
    
  }
  
  return(df)
  
}


# Get outcome (impact speed) for case ID with given glance time before and after tauinv.
get_y <- function(ID, before, after) {
  y <- as.numeric(df_with_y$y[df_with_y$ID == ID & df_with_y$before == before & df_with_y$after == after])
}
get_y <- Vectorize(get_y, c("ID", "before", "after"))


# Weighted negative log-likelihood of two-parameter distribution with density dens.
wnll <- function(par, y, w, p, dens) {
  - sum(w * p * dens(y, par[1], par[2], log = TRUE))
}


# Update collision probability and impact speed predictions.
update_predictions <- function(labelled, unlabelled) {
  
  defaultW <- getOption("warn")
  
  ymin <- min(labelled$y)
  ymax <- max(labelled$y)
  
  
  # Find all collision corner cases.
  selectedCrash <- labelled %>% filter(y > 0 & selected)
  exclude <- numeric(0)
  if ( nrow(selectedCrash) == 1 ) {
    cornersMax <- selectedCrash
  } else {
    for ( j in 1:nrow(selectedCrash) ) {
      exclude <- c(exclude, setdiff(which(selectedCrash$after >= selectedCrash$after[j] &
                                            selectedCrash$before >= selectedCrash$before[j]), j))
    }
  }
  ix <- setdiff(1:nrow(selectedCrash), exclude)
  cornersCrash <- selectedCrash[ix, ]
  
  
  # Prepare data for model fitting using fractional polynomials.
  form <- ~ -1 + I((0.1 + before)^(-3)) + I((0.1 + before)^(-2)) + 
    I((0.1 + before)^(-1)) + I((0.1 + before)^(-0.5)) +
    log(0.1 + before) + before + I(before^0.5) + I(before^2) + I(before^3) + 
    I((0.1 + after)^(-3)) + I((0.1 + after)^(-2)) + 
    I((0.1 + after)^(-1)) + I((0.1 + after)^(-0.5)) +
    log(0.1 + after) + after + I(after^0.5) + I(after^2) + I(after^3)
  X <- model.matrix(form, data = labelled)
  newX <- model.matrix(form, data = unlabelled)
  ntrain <- nrow(X)
  ix <- sample(1:ntrain) # Scramble training data.
  y <- labelled$y[ix]
  X <- X[ix, ]
  
  
  # Estimate impact speed. --
  options(warn = -1)
  ix <- which(labelled$y > ymin & labelled$y < ymax)
  
  # Random forest.
  if ( length(ix) > 1 ) {
    rf <- randomForest(y ~ after + before, data = labelled[ix, ])
    yhat1 <- predict(rf, unlabelled)
    yhat1[yhat1 <= 0] <- max(min(yhat1[yhat1 > 0]), ymin)
    yhat1[yhat1 > ymax] <- ymax
  } else {
    yhat1 <- rep((ymin + ymax) / 2, nrow(unlabelled))
  }
  
  # Fractional polynomial LASSO regression.
  if ( length(ix) > 2 ) {
    ix <- which(y > 0 & y < ymax)
    
    lasso <- cv.glmnet(X[ix, ], y[ix], grouped = FALSE)
    yhat2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"), 
                        nfolds = min(length(ix), 10))
    yhat2[yhat2 <= 0] <- max(min(yhat2[yhat2 > 0]), ymin)
    yhat2[yhat2 > ymax] <- ymax
    
  } else {
    yhat2 <- yhat1
  }
  
  
  # Estimate collision probability. --
  
  # Random forest.
  if ( ymin == 0 ) {
    rf <- randomForest(as.factor(y > 0) ~ after + before, data = labelled)
    ppos1 <- predict(rf, unlabelled, type = "prob")[, 2]
    ppos1[ppos1 <= 0] <- min(ppos1[ppos1 > 0])
  } else {
    ppos1 <- 1
  }
  
  # Fractional polynomial LASSO logistic regression.
  if ( sum(y == 0) > 2 & sum(y > 0) > 2 ) {
    lasso <- cv.glmnet(X, as.factor(y > 0), family = "binomial", grouped = FALSE)
    ppos2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    ppos2[ppos2 <= 0] <- min(ppos2[ppos2 > 0])
  } else {
    ppos2 <- ppos1
  }
  
  
  # Estimate max impact speed collision probability. --
  
  # Random forest.
  rf <- randomForest(as.factor(y == ymax) ~ after + before, data = labelled)
  pmax1 <- predict(rf, unlabelled, type = "prob")[, 2]
  pmax1[pmax1 <= 0] <- min(pmax1[pmax1 > 0])
  
  # Fractional polynomial LASSO logistic regression.
  if ( sum(y == ymax) > 2 & sum(y == ymax) > 2 ) {
    lasso <- cv.glmnet(X, as.factor(y == ymax), family = "binomial", grouped = FALSE)
    pmax2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    pmax2[pmax2 <= 0] <- min(pmax2[pmax2 > 0])
  } else {
    pmax2 <- pmax1
  }
  options(warn = defaultW)
  
  
  # Combine and add predictions to unlabelled dataset.
  ppos <- (ppos1 + ppos2) / 2
  pmax <- (pmax1 + pmax2) / 2
  yhat <- (yhat1 + yhat2) / 2
  ypred <- ppos * yhat + pmax * (ymax - yhat)
  ypred[ypred <= 0] <- min(ypred[ypred > 0]) # Zero impact speed not allowed.
  
  unlabelled %<>% 
    dplyr::select(-prob_positive, -yhat) %>% 
    mutate(prob_positive = ppos,
           yhat = ypred)
  
  # Find certainty crashes, set crash probability to 1 for observations "to the right or above".
  for ( j in 1:nrow(unlabelled) ) {
    unlabelled$prob_positive[j] <- ifelse(any(unlabelled$after[j] >= cornersCrash$after & 
                                                unlabelled$before[j] >= cornersCrash$before), 
                                          1, unlabelled$prob_positive[j])
  }
  
  return(unlabelled)
  
}


# Estimate impact speed distribution.
fitdist <- function(data) {
  
  crashes <- data %>% filter(y > 0)
  
  # Log-normal distribution.
  lnfit <- with(crashes, optim(c(0, 1), function(par) wnll(par, dens = dlnorm, y = y, w = w, p = glance_prob)))
  
  # Gamma distribution.
  mu <- with(crashes, sum(glance_prob * y) / sum(glance_prob))
  sigma2 <- with(crashes, sum(glance_prob * (y - mu)^2) / sum(glance_prob))
  theta0 <- c(shape = mu^2 / sigma2, rate = mu / sigma2) # Initial value.
  gamfit <- with(crashes, optim(theta0, function(par) wnll(par, dens = dgamma, y = y, w = w, p = glance_prob)))
  
  # Choose best fitting model.
  if ( gamfit$value < lnfit$value ) {
    fit <- gamfit
    fit$dist <- "gamma"
  } else {
    fit <- lnfit
    fit$dist <- "lognormal"
  }
  return(fit)
}


# Calculate sampling scheme.
calculate_sampling_scheme <- function(data, crit, fit) {
  
  if ( crit == "uniform" ) {
    
    pi <- rep(1, nrow(data))
    
  } else if ( crit == "prob" ) {
    
    pi <- with(data, glance_prob * sqrt(prob_positive))
    
  } else if ( crit == "mean" ) {
    
    pi <- with(data, glance_prob * sqrt(prob_positive) * yhat)
    
  } else if ( crit == "moments" ) {
    
    size <- with(data, yhat + yhat^2 + yhat^3 + yhat^4)
    pi <- with(data, glance_prob * sqrt(prob_positive) * size)
    
  } else if ( crit == "std_moments" ) {
    
    size <- with(data, yhat / sd(yhat) + yhat^2 / sd(yhat^2) + yhat^3 / sd(yhat^3) + yhat^4 / sd(yhat^4))
    pi <- with(data, glance_prob * sqrt(prob_positive) * size)    
  } else if ( crit == "nll" ) {
    
    print("Not implemented yet!")
    
  } else if ( crit == "KL" ) {
    
    print("Not implemented yet!")
    
  }
  
  return(pi / sum(pi))
  
}


# Add data-points with certain outcomes (no crash or max impact speed crash) 
# to labelled set, remove from unlabelled set.
add_certainty_outcomes <- function(new_sample, labelled, unlabelled) {
  
  for ( i in unique(new_sample$ID) ) { # Iterate over all cases.
    
    # Min and max impact speed for current case.
    labelled_i <- labelled %>% 
      filter(ID == i)
    ymin <- min(labelled_i$y)
    ymax <- max(labelled_i$y)
    
    # New data for current case.
    labelled_ij <- new_sample %>% 
      filter(ID == i)
    
    
    for ( j in 1:nrow(labelled_ij) ) { # Iterative over all labelled data points.
      
      newx <- labelled_ij[j, ]
      
      if ( newx$y == ymin ) { # Add certainty non-crashes.
        ix <- with(unlabelled, which(ID == i & before <= newx$before & after <= newx$after))
        
        add <- unlabelled %>% 
          filter(row_number() %in% ix) %>%
          mutate(y = ymin) %>% 
          dplyr::select(-yhat, -prob_positive)
        
        labelled <- labelled %>%
          add_row(add)
        
        if ( length(ix) > 0) {
          unlabelled <- unlabelled[-ix, ]
        }
        
      } else if ( newx$y == ymax ) { # Add certainty max impact speed crashes.
        
        ix <- with(unlabelled, which(ID == i & before >= newx$before & after >= newx$after))
        
        add <- unlabelled %>% 
          filter(row_number() %in% ix) %>%
          mutate(y = ymax) %>% 
          dplyr::select(-yhat, -prob_positive)
        
        labelled <- labelled %>%
          add_row(add)
        
        if ( length(ix) > 0) {
          unlabelled <- unlabelled[-ix, ]
        }
      }
    }
  }
  
  return(list(labelled = labelled, unlabelled = unlabelled))
  
}





active_learning <- function(data, niter = 1e2, bsize = 10, crit = "mean", plot = FALSE, plotit = 1:niter, fcount = 1) {
  # INPUT
  # data: input data set with variables 
  #   - 'after': glance duration after tauinv = 0.2 s.
  #   - 'before': (glance duration before tauinv = 0.2 s.
  #   - 't': total glance duration (s).
  #   - 'glance_prob': probability of glance.
  #   - 'ID': ID for specific case. 
  # niter: number of iterations.
  # bsize: number of datapoints to sample.
  # crit: optimisation criterion. Should be one of "uniform", "mean", "prob", "moments" or "std_moments".
  # plot: should plots be saved (TRUE/FALSE). 
  # plotit: iteration numbers for which plots will be generated.
  # fcount: starting index for figure numbers.
  #
  # OUTPUT: list of three datasets:
  #   - all: all 'labelled' observations (i.e. for which the outcome has been observed).
  #   - crashes: all generated crashes. 
  #   - noncrashes: all generated non-crashes.
  #   - figures stored in Output folder.
  
  
  # Start grid.
  grid <- tibble(after = c(0, 2, 4, 6.1), before = 0) %>% 
    add_row(after = c(1, 1.5, 3), before = c(3, 1.5, 1)) %>% 
    add_row(after = c(0.5, 4.5), before = c(4.5, 0.5)) %>%
    add_row(after = 3, before = 3) %>%
    mutate(selected = 1)
  
  # Labelled set.
  labelled <- data %>% 
    left_join(grid, by = c("after", "before")) %>%
    filter(selected == 1) %>% 
    mutate(y = get_y(ID, before, after),
           w = 1)
  
  # Unlabelled set.
  unlabelled <- data %>% 
    left_join(grid, by = c("after", "before")) %>%
    filter(is.na(selected)) %>% 
    mutate(w = 0,
           selected = 0,
           yhat = NA,
           prob_positive = NA)
  
  
  # Iterate
  new_sample <- labelled 
  k <- 1
  for ( i in 1:niter ) {
    
    print(sprintf("Iteration %d", i))
    
    # Add data-points with certain outcomes (no crash or max impact speed crash) 
    # to labelled set, remove from unlabelled set.
    update <- add_certainty_outcomes(new_sample, labelled, unlabelled)
    labelled <- update$labelled
    unlabelled <- update$unlabelled
    
    
    # First iteration: set all weights to 1 for labelled data points.
    if ( i == 1) {
      labelled$w <- 1
    }
    
    # Update predictions for cases with new data.
    for ( j in unique(new_sample$ID) ) {
      
      print(sprintf("Case = %d", j))
      
      # Update predictions.
      pred <- update_predictions(labelled %>% filter(ID == j), 
                                 unlabelled %>% filter(ID == j)) %>% 
        dplyr::select(ID, before, after, yhat, prob_positive)
      
      # Merge to unlabelled dataset.
      unlabelled %<>%
        left_join(pred, by = c("ID", "before", "after")) %>%
        mutate(yhat = ifelse(!is.na(yhat.y), yhat.y, yhat.x),
               prob_positive = ifelse(!is.na(prob_positive.y), prob_positive.y, prob_positive.x)) %>% 
        dplyr::select(-yhat.x, -yhat.y, -prob_positive.x, -prob_positive.y)
      
    } # End for j in unique(new_sample$ID)
    
    
    # Fit model to impact speed distribution. Currently not used.
    fit <- fitdist(labelled)
    
    # Calculate sampling probabilities. 
    pi <- calculate_sampling_scheme(unlabelled, crit, fit)
    
    
    # Plots.
    if ( plot & i %in% plotit ) {
      
      if ( length(unique(labelled$ID)) == 1 ) {
        if ( i == 1) {
          p1 <- ggplot(data = labelled %>% filter(selected == 1)) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            coord_equal() +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            expand_limits(y = 6.1) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "EOFF before tauinv = 0.2 (s)",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.6, "cm")) 
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "EOFF before tauinv = 0.2 (s)",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.6, "cm")) 
        } else {
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            geom_rect(data = new_sample, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05), fill = "firebrick") +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "EOFF before tauinv = 0.2 (s)",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.6, "cm")) 
          
        }
        
        p3 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = prob_positive)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y>0), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          expand_limits(y = 7) +
          coord_equal() +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Anticipated collision probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "EOFF before tauinv = 0.2 (s)",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = c(0, 0.925),
                legend.key.height = unit(0.3, "cm"),
                legend.key.width = unit(1.19, "cm"))
        
        p4 <- ggplot(data = labelled) +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = yhat)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
          expand_limits(y = 7) +
          coord_equal() +
          expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
          labs(title = "",
               subtitle = "Anticipated impact speed (km/h)",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "EOFF before tauinv = 0.2 (s)",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = c(0, 0.925),
                legend.key.height = unit(0.3, "cm"),
                legend.key.width = unit(1.19, "cm"))
        
        p5 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = pi)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05), fill = "grey40", colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          expand_limits(y = 7) +
          coord_equal() +
          labs(title = "",
               subtitle = "Sampling probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "EOFF before tauinv = 0.2 (s)",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = c(0, 0.925),
                legend.key.height = unit(0.3, "cm"),
                legend.key.width = unit(1.19, "cm"))
        
        if ( i == 1 ) {
          ggsave(sprintf("Output/fig%d.png", fcount), p1, dpi = 1000, width = 90, height = 90, unit = "mm")
          fcount <- fcount + 1 
        }
        ggsave(sprintf("Output/fig%d.png", fcount), p2, dpi = 1000, width = 90, height = 90, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), plot_grid(p3, p4, p5, ncol = 3, align = "vh", axis = "tblr"), 
               dpi = 1000, width = 270, height = 100, unit = "mm")
        fcount <- fcount + 1 
        
      } else {
        
        ptsize <- 20
        ptsmall <- 16
        theme_set(theme_bw()) 
        theme_update(axis.text = element_text(size = ptsize, colour = "black", family = "sans"),
                     axis.line = element_line(colour = "black", size = 0.25), 
                     axis.ticks = element_line(colour = "black", size = 0.25), 
                     legend.key.width = unit(2, "cm"),
                     legend.key.height = unit(0.4, "cm"),
                     legend.margin = ggplot2::margin(t = -0.25, unit = 'cm'),
                     legend.spacing =  unit(0, "cm"),
                     legend.position = "bottom",
                     legend.text = element_text(size = ptsmall, colour = "black", family = "sans"),
                     legend.title = element_text(size = ptsmall, colour = "black", family = "sans"),
                     strip.background.x = element_blank(),
                     panel.grid = element_blank(),
                     plot.subtitle = element_text(size = ptsmall, colour = "black", family = "sans", face = "plain", hjust = 0),
                     plot.title = element_text(size = ptsize, colour = "black", family = "sans", face = "plain", hjust = 0),
                     text = element_text(size = ptsize, colour = "black", family = "sans"))
        
        if ( i == 1) {
         
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            facet_wrap(~ID, ncol = 3, nrow = 2, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "EOFF before tauinv = 0.2 (s)",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.5, "cm"),
                  legend.key.width = unit(2, "cm"))
        } else {
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            geom_rect(data = new_sample, aes(xmin = after - 0.1, xmax = after + 0.1, ymin = before - 0.1, ymax = before + 0.1), fill = "firebrick") +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            facet_wrap(~ID, ncol = 3, nrow = 2, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "EOFF before tauinv = 0.2 (s)",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.5, "cm"),
                  legend.key.width = unit(2, "cm"))
          
        }
        
        p3 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = prob_positive)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y>0), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          facet_wrap(~ID, ncol = 3, nrow = 2, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
          coord_equal() +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Anticipated collision probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "EOFF before tauinv = 0.2 (s)",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm"))
        
        p4 <- ggplot(data = labelled) +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = yhat)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
          facet_wrap(~ID, ncol = 3, nrow = 2, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
          coord_equal() +
          expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Anticipated impact speed (km/h)",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "EOFF before tauinv = 0.2 (s)",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm"))
        
        p5 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = pi)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05), fill = "grey40", colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          facet_wrap(~ID, ncol = 3, nrow = 2, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
          coord_equal() +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Sampling probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "EOFF before tauinv = 0.2 (s)",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm"))

        ggsave(sprintf("Output/fig%d.png", fcount), p2, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p3, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p4, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p5, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        
      }
      
    }
    
    
    # Sample new observations.
    ix <- as.numeric(rmultinom(n = 1, size = bsize, prob = pi))
    new_wt <- ix / (bsize * pi)
    
    # Get data for sampled observations.
    new_sample <- unlabelled %>% 
      mutate(new_wt = new_wt) %>% 
      filter(new_wt > 0) %>% 
      mutate(y = get_y(ID, before, after),
             selected = 1) %>% 
      dplyr::select(-prob_positive, -yhat)
    
    
    # Update labelled and unlabelled sets.
    labelled <- labelled %>%
      mutate(new_wt = 1) %>% # Re-query labelled data points with probability 1. 
      add_row(new_sample) %>%
      mutate(w = w + (new_wt - w) / k) %>%
      dplyr::select(-new_wt)
    
    unlabelled %<>%
      mutate(new_wt = new_wt) %>% 
      filter(new_wt <= 0) %>% 
      dplyr::select(-new_wt)
    
    # Increase counter if at least one new crash has been generated.
    k <- k + (any(new_sample$y > 0))
    
    
  } # End active learning.
  
  labelled <- labelled 
  
  crashes <- labelled %>% 
    filter(y > 0) %>% 
    mutate(w_final = w * glance_prob)
  
  noncrashes <- labelled %>% 
    filter(y == 0)
  
  return(list(all = labelled, crashes = crashes, noncrashes = noncrashes))
  
}
