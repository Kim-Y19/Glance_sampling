update_predictions <- function(labelled, unlabelled, verbose = FALSE, plot = FALSE) {

  defaultW <- getOption("warn")
  
  # Transform impact speed to common range [0, 1].
  maximpact0 <- labelled %>%
    group_by(caseID) %>%
    summarise(maximpact0 = max(impact_speed0, na.rm = TRUE), .groups = "keep") %>%
    ungroup() %>%
    dplyr::select(caseID, maximpact0)

  labelled %<>%
    left_join(maximpact0, by = "caseID") %>% 
    mutate(sampling_weight = ifelse(sampling_weight == 0, 1, sampling_weight), # Set sampling weight of certainty-selections to unity.
           final_weight = sampling_weight * eoff_acc_prob)
  labelled$caseID <- factor(labelled$caseID)
  
  unlabelled %<>%
    left_join(maximpact0, by = "caseID") 
  unlabelled$caseID <- factor(unlabelled$caseID)
  
  
  # Some variables.
  crash0 <- unlabelled$crash0
  non_crash0 <- unlabelled$non_crash0
  max_impact0 <- unlabelled$max_impact0
  crash1 <- unlabelled$crash1
  non_crash1 <- unlabelled$non_crash1
  max_impact0 <- unlabelled$max_impact0
  max_impact1 <- unlabelled$max_impact1
  
  # Hyper-parameter tuning grid for random forest regression and classification.
  regGrid <- expand.grid(splitrule = "variance", 
                         min.node.size = 1:20,
                         mtry = 1:(length(unique(labelled$caseID)) + 2))
  
  classGrid <- expand.grid(splitrule = "gini", 
                           min.node.size = 1:20,
                           mtry = 1:(length(unique(labelled$caseID)) + 1))
  
  
  # Predict baseline impact speed. ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- regGrid[sample(1:nrow(regGrid), 3), ]
  rf <- try(caret::train(impact_speed0 ~ caseID + eoff + acc + maximpact0, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         weights = labelled$final_weight,
                         respect.unordered.factors = "partition",
                         tuneGrid = grid,
                         trControl = trainControl(method = "cv",
                                                  number = 5)),
            silent = TRUE)
  options(warn = defaultW)
  
  if ( !inherits(rf, "try-error") ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    xhat_train <- predict(rf, labelled)
    xhat_test <- predict(rf, unlabelled)

    # Root mean squared prediction error and prediction R-squared.
    rmse_xhat <- sqrt(rf$finalModel$prediction.error) 
    r2_xhat <- rf$finalModel$r.squared
    
  } else { # If unable to fit model: set to constant.
    
    xhat_train <- 1
    xhat_test <- 1
    rmse_xhat <- NA
    r2_xhat <- NA
    
  }

 
  # Predict impact speed reduction ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- regGrid[sample(1:nrow(regGrid), 3), ]
  rf <- try(caret::train(impact_speed_reduction ~ caseID + eoff + acc + maximpact0, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         weights = labelled$final_weight,
                         respect.unordered.factors = "partition",
                         tuneGrid = grid,
                         trControl = trainControl(method = "cv",
                                                  number = 5)),
            silent = TRUE)
  options(warn = defaultW)
  
  if ( !inherits(rf, "try-error") ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    yhat_train <- predict(rf, labelled)
    yhat_test <- predict(rf, unlabelled)
    
    # Root mean squared prediction error and prediction R-squared.
    rmse_yhat <- sqrt(rf$finalModel$prediction.error) 
    r2_yhat <- rf$finalModel$r.squared
    
  } else { # If unable to fit model: set to constant.
    
    yhat_train <- 1
    yhat_test <- 1
    rmse_yhat <- NA
    r2_yhat <- NA
    
  }
  
  
  # Predict injury risk reduction. ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- regGrid[sample(1:nrow(regGrid), 3), ]
  rf <- try(caret::train(injury_risk_reduction ~ caseID + eoff + acc + maximpact0, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         weights = labelled$final_weight,
                         respect.unordered.factors = "partition",
                         tuneGrid = grid,
                         trControl = trainControl(method = "cv",
                                                  number = 5)),
            silent = TRUE)
  options(warn = defaultW)
  
  if ( !inherits(rf, "try-error") ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    zhat_train <- predict(rf, labelled)
    zhat_test <- predict(rf, unlabelled)
    
    # Root mean squared prediction error and prediction R-squared.
    rmse_zhat <- sqrt(rf$finalModel$prediction.error) 
    r2_zhat <- rf$finalModel$r.squared
    
  } else { # If unable to fit model: set to constant.
    
    zhat_train <- 1
    zhat_test <- 1
    rmse_zhat <- NA
    r2_zhat <- NA
    
  }
  
  
  # Estimate baseline collision probability. ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- classGrid[sample(1:nrow(classGrid), 3), ]
  rf <- try(caret::train(factor(impact_speed0 > 0, labels = paste0("Y", 0:1)) ~ caseID + eoff + acc, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         weights = labelled$final_weight,
                         respect.unordered.factors = "partition",
                         tuneGrid = grid,
                         trControl = trainControl(method = "cv",
                                                  number = 5,
                                                  classProbs = TRUE)),
            silent = TRUE)
  options(warn = defaultW)
  
  if ( !inherits(rf, "try-error") ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    p0_train <- predict(rf, labelled, type = "prob")$Y1
    p0_train[p0_train <= 0] <- min(p0_train[p0_train > 0]) # Avoid zero probabilities.
    
    p0_test <- predict(rf, unlabelled, type = "prob")$Y1
    p0_test[p0_test <= 0] <- min(p0_test[p0_test > 0]) # Avoid zero probabilities.
    
    # Accuracy.
    ix <- with(rf$results, which(min.node.size == rf$finalModel$min.node.size & mtry == rf$finalModel$mtry))
    p0_acc <- rf$results[ix, "Accuracy"]
    
  } else { # If unable to fit model: set to constant.
    
      p0_train <- 1
      p0_test <- 1
      p0_acc <- NA
    
  } # End !is.null(rf).
  
  
  # Estimate counter-measure collision probability. ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- classGrid[sample(1:nrow(classGrid), 3), ]
  rf <- try(caret::train(factor(impact_speed1 > 0, labels = paste0("Y", 0:1)) ~ caseID + eoff + acc, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         weights = labelled$final_weight,
                         respect.unordered.factors = "partition",
                         tuneGrid = grid,
                         trControl = trainControl(method = "cv",
                                                  number = 5,
                                                  classProbs = TRUE)),
            silent = TRUE)
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    p1_train <- predict(rf, labelled, type = "prob")$Y1
    p1_train[p1_train <= 0] <- min(p1_train[p1_train > 0]) # Avoid zero probabilities.
    
    p1_test <- predict(rf, unlabelled, type = "prob")$Y1
    p1_test[p1_test <= 0] <- min(p1_test[p1_test > 0]) # Avoid zero probabilities.
    
    # Accuracy.
    ix <- with(rf$results, which(min.node.size == rf$finalModel$min.node.size & mtry == rf$finalModel$mtry))
    p1_acc <- rf$results[ix, "Accuracy"]
    
  } else { # If unable to fit model: set to constant.
    
      p1_train <- 1
      p1_test <- 1
      p1_acc <- NA
    
  } # End !is.null(rf).
  
  
  # Combine to calculate predictions on labelled  data. 
  labelled %<>%
    mutate(impact_speed0_pred = xhat_train, 
           impact_speed_reduction_pred = yhat_train, 
           injury_risk_reduction_pred = zhat_train, 
           collision_prob0_pred = p0_train, 
           collision_prob1_pred = p1_train) 
  
   # Print.
  if ( verbose ) {
    
    cat(sprintf("R-squared, training data:
Baseline impact speed = %.2f
Impact speed reduction = %.2f
Injury risk reduction = %.2f.

Accuracy, traning data
Baseline crash probability = %.2f
Counter-meature crash probability = %.2f.
                ", 
                r2_xhat, 
                r2_yhat,
                r2_zhat,
                p0_acc,
                p1_acc))
    cat("\n")
    
  }
  
  
  # Add logic.
  p0_test <- pmax(p0_test, crash0, na.rm = TRUE) # Certainty crashes.
  p0_test <- pmin(p0_test, 1 - non_crash0, na.rm = TRUE)  # Certainty non-crashes.
  p1_test <- pmax(p1_test, crash1, na.rm = TRUE) 
  p1_test <- pmin(p1_test, 1 - non_crash1, na.rm = TRUE) 
  
  xhat_test <- unlabelled %>% 
    mutate(impact_speed0_pred = ifelse( !is.na(max_impact0) & max_impact0 == 1, maximpact0, xhat_test)) %>% 
    dplyr::select(impact_speed0_pred) %>% 
    pull()
  
  
  # Plot.
  if ( plot ) {
    par(mfrow = c(1, 3))
    plot(labelled$impact_speed0_pred, labelled$impact_speed0, bty = "l", col = labelled$caseID)
    abline(0, 1)
    plot(labelled$eoff, labelled$impact_speed0, bty = "l", col = labelled$caseID)
    plot(labelled$eoff, labelled$impact_speed0_pred, bty = "l", col = labelled$caseID, ylim = range(labelled$impact_speed0))
    
    plot(labelled$impact_speed_reduction_pred, labelled$impact_speed_reduction, bty = "l", col = labelled$caseID)
    abline(0, 1)
    plot(labelled$eoff, labelled$impact_speed_reduction, bty = "l", col = labelled$caseID)
    plot(labelled$eoff, labelled$impact_speed_reduction_pred, bty = "l", col = labelled$caseID, ylim = range(labelled$impact_speed_reduction))
    
    plot(labelled$injury_risk_reduction_pred, labelled$injury_risk_reduction, bty = "l", col = labelled$caseID)
    abline(0, 1)
    plot(labelled$eoff, labelled$injury_risk_reduction, bty = "l", col = labelled$caseID)
    plot(labelled$eoff, labelled$injury_risk_reduction_pred, bty = "l", col = labelled$caseID, ylim = range(labelled$injury_risk_reduction))
    
    par(mfrow = c(1, 2))
    plot(labelled$collision_prob0_pred, labelled$impact_speed0 > 0, bty = "l")
    plot(labelled$collision_prob1_pred, labelled$impact_speed1 > 0, bty = "l")
    par(mfrow = c(1, 1))
    
    
    par(mfrow = c(1, 3))
    plot(xhat_test, unlabelled$impact_speed0, bty = "l", col = unlabelled$caseID)
    abline(lm(unlabelled$impact_speed0~xhat_test))
    abline(0, 1, col = "red")
    plot(unlabelled$eoff, unlabelled$impact_speed0, bty = "l", col = unlabelled$caseID)
    plot(unlabelled$eoff, xhat_test, bty = "l", col = unlabelled$caseID, ylim = range(unlabelled$impact_speed0))
    
    plot(yhat_test, unlabelled$impact_speed_reduction, bty = "l", col = unlabelled$caseID)
    abline(lm(unlabelled$impact_speed_reduction~yhat_test))
    abline(0, 1, col = "red")
    plot(unlabelled$eoff, unlabelled$impact_speed_reduction, bty = "l", col = unlabelled$caseID)
    plot(unlabelled$eoff, yhat_test, bty = "l", col = unlabelled$caseID, ylim = range(unlabelled$impact_speed_reduction))
    
    plot(zhat_test, unlabelled$injury_risk_reduction, bty = "l", col = unlabelled$caseID)
    abline(lm(unlabelled$injury_risk_reduction~zhat_test))
    abline(0, 1, col = "red")
    plot(unlabelled$eoff, unlabelled$injury_risk_reduction, bty = "l", col = unlabelled$caseID)
    plot(unlabelled$eoff, zhat_test, bty = "l", col = unlabelled$caseID, ylim = range(unlabelled$injury_risk_reduction))
    
    par(mfrow = c(1, 2))
    plot(p0_test, unlabelled$impact_speed0 > 0, bty = "l")
    abline(lm(unlabelled$impact_speed0 > 0 ~ p0_test))
    plot(p1_test, unlabelled$impact_speed1 > 0, bty = "l")
    abline(lm(unlabelled$impact_speed1 > 0 ~ p1_test))
    par(mfrow = c(1, 1))
  }
  
  
  # Return.
  rmse_log_xhat <- with(labelled %>% filter(impact_speed0 > 0), sd(log(impact_speed0) - log(impact_speed0_pred)))
  return(list(collision_prob0 = p0_test, 
              collision_prob1 = p1_test,
              impact_speed0_pred = xhat_test,
              impact_speed_reduction_pred = yhat_test,
              injury_risk_reduction_pred = zhat_test,
              rmse_log_impact_speed0 = rmse_log_xhat,
              rmse_impact_speed_reduction = rmse_yhat,
              rmse_injury_risk_reduction = rmse_zhat,
              r2_impact_speed0 = r2_xhat,
              r2_impact_speed_reduction = r2_yhat,
              r2_injury_risk_reduction = r2_zhat,
              accuracy_crash0 = p0_acc,
              accuracy_crash1 = p1_acc))
  
}