update_predictions <- function(labelled, unlabelled, yvar) {
  
  defaultW <- getOption("warn")
  
  labelled$y <- pull(labelled[, yvar])
  
  if ( yvar == "impact_speed0" ) {
    
    crash <- unlabelled$crash0
    non_crash <- unlabelled$non_crash0
    max_impact <- unlabelled$max_impact0
    
  } else if ( yvar == "impact_speed1" ) {
    
    crash <- unlabelled$crash1
    non_crash <- unlabelled$non_crash1
    max_impact <- unlabelled$max_impact1
    
  }
  
  ymin <- min(labelled$y)
  ymax <- max(labelled$y)
  
 
  # Prepare data for model fitting using fractional polynomials.
  form <- ~ -1 + I((-acc)^(-3)) + I((-acc)^(-2)) +
    I((-acc)^(-1)) + I((-acc)^(-0.5)) +
    log(-acc) + I(-acc) + I((-acc)^0.5) + I((-acc)^2) + I((-acc)^3) +
    I((0.1 + eoff)^(-3)) + I((0.1 + eoff)^(-2)) +
    I((0.1 + eoff)^(-1)) + I((0.1 + eoff)^(-0.5)) +
    log(0.1 + eoff) + eoff + I(eoff^0.5) + I(eoff^2) + I(eoff^3)
  X <- model.matrix(form, data = labelled)
  newX <- model.matrix(form, data = unlabelled)
  ntrain <- nrow(X)
  ix <- sample(1:ntrain) # Scramble training data.
  y <- labelled$y[ix]
  X <- X[ix, ]
  
  
  # Estimate impact speed. ----
    
  # Random forest.
  options(warn = -1)
  rf <- safe_random_forest(y ~ eoff + acc, data = labelled %>% filter(y > 0 & y < ymax))
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    yhat1 <- predict(rf, unlabelled)
    yhat1[yhat1 <= 0] <- max(min(yhat1[yhat1 > 0]), ymin)
    yhat1[yhat1 > ymax] <- ymax
    
  } else { # If unable to fit model: use mean of min and max impact speed. 
    
    yhat1 <- rep((ymin + ymax) / 2, nrow(unlabelled))
    
  }
  
  
  # Fractional polynomial LASSO regression.
  ix <- which(y > 0 & y < ymax)
  nfolds <- ifelse(length(ix) < 50, length(ix), 10)
  lasso <- safe_cv_glmnet(X[ix, ], y[ix], grouped = FALSE, nfolds = nfolds)
  
  if ( !is.null(lasso) ) { # If able to fit model: calculate predictions.
    
    yhat2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    yhat2[yhat2 <= 0] <- max(min(yhat2[yhat2 > 0]), ymin)
    yhat2[yhat2 > ymax] <- ymax
    
  } else { # If unable to fit model: use predictions from random forest. 
    
    yhat2 <- yhat1
    
  }

  
  # Estimate collision probability. ----
  
  # Random forest.
  options(warn = -1)
  rf <- safe_random_forest(as.factor(y > 0) ~ eoff + acc, data = labelled)
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    ppos1 <- as.numeric(predict(rf, unlabelled, type = "prob")[, 2])
    ppos1[ppos1 <= 0] <- min(ppos1[ppos1 > 0])
    
  } else { # If unable to fit model: set probabilities manually.
    
    if ( ymax == 0 ) { # If no crashes.
      
      ppos1 <- rep(0, nrow(unlabelled))
      
    } else if ( ymin > 0 ) { # If no non-crashes.
      
      ppos1 <- rep(1, nrow(unlabelled))
      
    } else {
      
      stop("Error in update_predictions > Estimate collision probability > Random forest >  Unable to fit model. Case not implemented. ")
      
    }
    
  } # End !is.null(rf).
  
 
  # Fractional polynomial LASSO logistic regression with outcome-stratified cross-validation. 
  nstrata <- min(min(table(y > 0)), 10)
  events <- which(y > 0) 
  nonevents <- which(!(y > 0)) 
  foldid <- rep(0, length(y))
  foldid[events] <- rep(1:nstrata, length(events))[1:length(events)]
  foldid[nonevents] <- rep(1:nstrata, length(nonevents))[1:length(nonevents)]
  
  lasso <- safe_cv_glmnet(X, as.factor(y > 0), family = "binomial", grouped = FALSE, foldid = foldid)
  
  if ( !is.null(lasso) ) { # If able to fit model: calculate predictions. 
    
    ppos2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    ppos2[ppos2 <= 0] <- min(ppos2[ppos2 > 0])
    
  } else { # If unable to fit model: use predictions from random forest. 
    
    ppos2 <- ppos1
  
  } 
  
  
  # Estimate max impact speed collision probability. ----
 
  # Random forest.
  options(warn = -1)
  rf <- randomForest(as.factor(y == ymax) ~ eoff + acc, data = labelled)
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    pmax1 <- predict(rf, unlabelled, type = "prob")[, 2]
    pmax1[pmax1 <= 0] <- min(pmax1[pmax1 > 0])
    
  } else { # If unable to fit model: set probabilities manually.
    
    if ( ymin == ymax ) { # If all crashes at maximal impact speed.
      
      pmax1 <- pmax2 <- rep(1, nrow(unlabelled))
      
    } else {
      
      stop("Error in update_predictions > Estimate max impact speed collision probability > Random forest >  Unable to fit model. Case not implemented. ")
      
    }
  }
 
  
  # Fractional polynomial LASSO logistic regression with outcome-stratified cross-validation.
  nstrata <- min(min(table(y == ymax)), 10)
  events <- which(y == ymax) 
  nonevents <- which(!(y == ymax)) 
  foldid <- rep(0, length(y))
  foldid[events] <- rep(1:nstrata, length(events))[1:length(events)]
  foldid[nonevents] <- rep(1:nstrata, length(nonevents))[1:length(nonevents)]
  
  lasso <- safe_cv_glmnet(X, as.factor(y == ymax), family = "binomial", grouped = FALSE, foldid = foldid)
  
  if ( !is.null(lasso) ) { # If able to fit model: calculate predictions. 
    
    pmax2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
    pmax2[pmax2 <= 0] <- min(pmax2[pmax2 > 0])
    
  } else { # If unable to fit model: use predictions from random forest. 
    
    pmax2 <- pmax1
    
  } 

  
  # Combine predictions + add logic.
  ppos <- pmax((ppos1 + ppos2) / 2, crash, na.rm = TRUE) 
  ppos <- ifelse( !is.na(non_crash) & non_crash, rep(0, length(ppos)), ppos)
  pmax <- pmax((pmax1 + pmax2) / 2, max_impact, na.rm = TRUE) 
  pmax <- ifelse( !is.na(non_crash) & non_crash, rep(0, length(pmax)), pmax)
  yhat <- (yhat1 + yhat2) / 2
  ypred <- ppos * yhat + pmax * (ymax - yhat)

  return(list(collision_prob = as.numeric(ppos), impact_speed_pred = as.numeric(ypred)))
  
}