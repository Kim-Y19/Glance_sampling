prepare_df_with_y <- function(loadfile, glance, dec, plotit = TRUE){
  df_with_y =  read_pickle_file(loadfile)
  drops <- c("t")
  df_with_y = df_with_y[ , !(names(df_with_y) %in% drops)]
  df_with_y = df_with_y[!duplicated(df_with_y),]
  transform(df_with_y,before = as.numeric(before), after = as.numeric(after),
            glance_prob = as.numeric(glance_prob),y = as.numeric(y))
  df_with_y$y = as.numeric(df_with_y$y)
  for ( i in unique(df_with_y$ID) ){ # Iterate over all cases.
    labelled = df_with_y[df_with_y$ID == i,]
    for ( j in unique(labelled$before) ) {
      labelled_dec = labelled[labelled$before == j,]
      labelled_dec = labelled_dec[order(labelled_dec$after),]
      dec_weight = dec$dec_weight[which(dec$dec == j)] 
      if (length(labelled_dec[labelled_dec$y == 0,]$after)>0)
      {
        min_index = max(labelled_dec[labelled_dec$y == 0,]$after)
        min_index = which(glance$glance_duration == min_index)
      }
      else
      {
        min_index = 0
      }
      if (length(labelled_dec[labelled_dec$y == labelled_dec[nrow(labelled_dec)-1,]$y,]$after)>0 &
          labelled_dec[nrow(labelled_dec),]$y != 0)
      {
        max_index = min(labelled_dec[labelled_dec$y == labelled_dec[nrow(labelled_dec),]$y,]$after)
        max_index = which(glance$glance_duration == max_index)
      }
      else{
        max_index = 0
      }
      max_v = tail(labelled_dec$y, n =1)
      if (min_index > 2){
        for (k in 2:(min_index-1)){
          if(length(which(labelled_dec$after == glance$glance_duration[k]))==0){
            df_with_y[nrow(df_with_y) + 1,] = c(j,
                                                glance$glance_duration[k],
                                                glance$glance_weight[k]*dec_weight,
                                                i,
                                                0)
          }
          
        }
      }
      if (max_index < length(glance$glance_duration) & max_index > 0) {
        for (k in (max_index +1):length(glance$glance_duration)){
          if(length(which(labelled_dec$after == glance$glance_duration[k])) == 0){
            df_with_y[nrow(df_with_y) + 1,] = c(j,
                                                glance$glance_duration[k],
                                                glance$glance_weight[k]*dec_weight,
                                                i,
                                                max_v)
          }
        }
      }
      if(min(df_with_y[df_with_y$ID == i & df_with_y$before == j & df_with_y$after == tail(glance$glance_duration,1),]$y) == 0){
        df_with_y[df_with_y$ID == i & df_with_y$before == j,]$y = 0
      }
      if(plotit){
        plot(as.numeric(df_with_y[df_with_y$ID == i,]$after),df_with_y[df_with_y$ID == i,]$before,col = 'red',
             main = c('CaseID:',i),
             xlab = 'Glance duration',
             ylab = 'Deceleration',
             xlim = c(0,6.5))
      }
    }
  }
  df_with_y = df_with_y[!duplicated(df_with_y),]
  df_with_y = df_with_y[order(df_with_y$ID,df_with_y$before,df_with_y$after),]
  for ( i in unique(df_with_y$ID) ) { 
    labelled = df_with_y[df_with_y$ID == i,]
    for ( j in unique(labelled$before) ) { 
      labelled_dec = labelled[labelled$before == j,]
      labelled_dec = labelled_dec[order(labelled_dec$after),]
      glance_sum = sum(glance$glance_weight[-1])
      df_with_y[(df_with_y$ID == i & df_with_y$before == j),]$glance_prob = as.numeric(df_with_y[df_with_y$ID == i & df_with_y$before == j,]$glance_prob)/(1-glance$glance_weight[1])
      sum(as.numeric(df_with_y[(df_with_y$ID == i & df_with_y$before == j),]$glance_prob))
    }
    sum(as.numeric(df_with_y[df_with_y$ID == i,]$glance_prob))
  }
  transform(df_with_y,before = as.numeric(before), after = as.numeric(after),
            glance_prob = as.numeric(glance_prob),y = as.numeric(y))
  df_with_y$before = as.numeric(df_with_y$before)
  df_with_y$after = as.numeric(df_with_y$after)
  df_with_y$y = as.numeric(df_with_y$y)
  df_with_y$glance_prob = as.numeric(df_with_y$glance_prob)
  return(df_with_y)
}

# Simulate outcome.
simulate_y <- function(t1, t2, beta = runif(4) * c(1, 0.1, 10, 1), sigma = runif(1, 0, 2), ymin = rbinom(1, 1, 0.15) * runif(1, 0, 5), ymax = runif(1, 20, 50), q = c(runif(1, 0, 0.4), runif(1, 0.85, 1))) {
  
  z <- as.numeric(cbind(t1, t2) %*% beta[1:2] + cbind(log(0.1 + t1), log(0.1 + t2)) %*% beta[3:4]) + rnorm(length(t1), sd = sigma)
  zmin <- quantile(z, min(q))
  zmax <- quantile(z, max(q))
  
  if ( ymin > 0 ) {
    ix <- which(t1 == min(t1) & t2 == min(t2)) 
    zmin <- z[ix]
    z2 <- z
  } else {
    min_ix <- which(z <= zmin)
    z2 <- z
    z2[z <= zmin] <- zmin
    for (i in min_ix) {
      z2[which(t2 <= t2[i] & t1 <= t1[i])] <- zmin
    }
  }
  
  max_ix <- which(z2 >= zmax)
  z3 <- z2
  z3[2 >= zmax] <- zmax
  for (i in max_ix) {
    z3[which(t2 >= t2[i] & t1 >= t1[i])] <- zmax
  }
  z3[length(z3)] <- zmax
  
  y <- ymin + (z3 - zmin) / max(z3 - zmin) * (ymax - ymin)
  
  return(y)
}


# Simulate sample of cases.
simulate_sample <- function(ncases = 10) {
  
  df <- NULL
  for ( i in 1:ncases ) {
    
    dfi <- biv %>%
      mutate(ID = i, 
             y = simulate_y(t1 = after, t2 = before))
    
    df <- df %>% 
      rbind(dfi)
    
  }
  
  return(df)
  
}


# Get outcome (impact speed) for case ID with given glance time before and after tauinv.
get_y <- function(ID, before, after,optimizefactor) {
  if(optimizefactor == 'Impact_speed'){
    y <- as.numeric(df_with_y$y[df_with_y$ID == ID & df_with_y$before == before & df_with_y$after == after])
  }
  else if(optimizefactor == 'Injury_reduction'){
    y <- as.numeric(df_with_y$R[df_with_y$ID == ID & df_with_y$before == before & df_with_y$after == after])
  }
  else if(optimizefactor == 'Speed_reduction'){
    y <- as.numeric(df_with_y$dy[df_with_y$ID == ID & df_with_y$before == before & df_with_y$after == after])
  }
}
get_y <- Vectorize(get_y, c("ID", "before", "after"))
# Weighted negative log-likelihood of two-parameter distribution with density dens.
wnll <- function(par, y, w, p, dens) {
  - sum(w * p * dens(y, par[1], par[2], log = TRUE))
}


# Update collision probability and impact speed predictions.
update_predictions <- function(labelled, unlabelled) {
  
  defaultW <- getOption("warn")
  
  ymin <- min(labelled$y)
  ymax <- max(labelled$y)
  
  
  # Find all collision corner cases.
  selectedCrash <- labelled %>% filter(y > 0 & selected)
  exclude <- numeric(0)
  if ( nrow(selectedCrash) == 1 ) {
    cornersMax <- selectedCrash
  } else {
    for ( j in 1:nrow(selectedCrash) ) {
      exclude <- c(exclude, setdiff(which(selectedCrash$after >= selectedCrash$after[j] &
                                            selectedCrash$before >= selectedCrash$before[j]), j))
    }
  }
  ix <- setdiff(1:nrow(selectedCrash), exclude)
  cornersCrash <- selectedCrash[ix, ]
  
  
  # Prepare data for model fitting using fractional polynomials.
  form <- ~ -1 + I((- before)^(-3)) + I((-before)^(-2)) +
    I((-before)^(-1)) + I((-before)^(-0.5)) +
    log(-before) - before + I((-before)^0.5) + I(before^2) + I((-before)^3) +
    I((0.1 + after)^(-3)) + I((0.1 + after)^(-2)) +
    I((0.1 + after)^(-1)) + I((0.1 + after)^(-0.5)) +
    log(0.1 + after) + after + I(after^0.5) + I(after^2) + I(after^3)
  X <- model.matrix(form, data = labelled)
  newX <- model.matrix(form, data = unlabelled)
  ntrain <- nrow(X)
  ix <- sample(1:ntrain) # Scramble training data.
  y <- labelled$y[ix]
  X <- X[ix, ]
  
  
  # Estimate impact speed. --
  options(warn = -1)
  ix <- which(labelled$y > ymin & labelled$y < ymax)
  
  # Random forest.
  if ( length(ix) > 1 ) {
    rf <- randomForest(y ~ after + before, data = labelled[ix, ])
    yhat1 <- predict(rf, unlabelled)
    yhat1[yhat1 <= 0] <- max(min(yhat1[yhat1 > 0]), ymin)
    yhat1[yhat1 > ymax] <- ymax
  } else {
    yhat1 <- rep((ymin + ymax) / 2, nrow(unlabelled))
  }
  
  # Fractional polynomial LASSO regression.
  # if ( length(ix) > 2 ) {
  #   ix <- which(y > 0 & y < ymax)
  # 
  #   lasso <- cv.glmnet(X[ix, ], y[ix], grouped = FALSE)
  #   yhat2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"),
  #                       nfolds = min(length(ix), 10))
  #   yhat2[yhat2 <= 0] <- max(min(yhat2[yhat2 > 0]), ymin)
  #   yhat2[yhat2 > ymax] <- ymax
  # 
  # } else {
  #   yhat2 <- yhat1
  # }
  # 
  yhat2 <- yhat1
  # Estimate collision probability. --
  
  # Random forest.
  if ( ymin == 0 ) {
    rf <- randomForest(as.factor(y > 0) ~ after + before, data = labelled)
    ppos1 <- predict(rf, unlabelled, type = "prob")[, 2]
    ppos1[ppos1 <= 0] <- min(ppos1[ppos1 > 0])
  } else {
    ppos1 <- 1
  }
  
  # Fractional polynomial LASSO logistic regression.
  # if ( sum(y == 0) > 2 & sum(y > 0) > 2 ) {
  #   lasso <- cv.glmnet(X, as.factor(y > 0), family = "binomial", grouped = FALSE)
  #   ppos2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
  #   ppos2[ppos2 <= 0] <- min(ppos2[ppos2 > 0])
  # } else {
  #   ppos2 <- ppos1
  # }
  ppos2 <- ppos1
  
  # Estimate max impact speed collision probability. --
  
  # Random forest.
  rf <- randomForest(as.factor(y == ymax) ~ after + before, data = labelled)
  pmax1 <- predict(rf, unlabelled, type = "prob")[, 2]
  pmax1[pmax1 <= 0] <- min(pmax1[pmax1 > 0])
  
  # Fractional polynomial LASSO logistic regression.
  # if ( sum(y == ymax) > 2 & sum(y == ymax) > 2 ) {
  #   lasso <- cv.glmnet(X, as.factor(y == ymax), family = "binomial", grouped = FALSE)
  #   pmax2 <- as.numeric(predict(lasso, newx = newX, s = "lambda.1se", type = "response"))
  #   pmax2[pmax2 <= 0] <- min(pmax2[pmax2 > 0])
  # } else {
  #   pmax2 <- pmax1
  # }
  pmax2 <- pmax1
  options(warn = defaultW)
  
  
  # Combine and add predictions to unlabelled dataset.
  ppos <- (ppos1 + ppos2) / 2
  pmax <- (pmax1 + pmax2) / 2
  yhat <- (yhat1 + yhat2) / 2
  ypred <- ppos * yhat + pmax * (ymax - yhat)
  ypred[ypred <= 0] <- min(ypred[ypred > 0]) # Zero impact speed not allowed.
  
  unlabelled %<>% 
    dplyr::select(-prob_positive, -yhat) %>% 
    mutate(prob_positive = ppos,
           yhat = ypred)
  
  # Find certainty crashes, set crash probability to 1 for observations "to the right or above".
  for ( j in 1:nrow(unlabelled) ) {
    unlabelled$prob_positive[j] <- ifelse(any(unlabelled$after[j] >= cornersCrash$after & 
                                                unlabelled$before[j] >= cornersCrash$before), 
                                          1, unlabelled$prob_positive[j])
  }
  
  return(unlabelled)
  
}


# Estimate impact speed distribution.
fitdist <- function(data) {
  
  crashes <- data %>% filter(y > 0)
  
  # Log-normal distribution.
  lnfit <- with(crashes, optim(c(0, 1), function(par) wnll(par, dens = dlnorm, y = y, w = w, p = glance_prob)))
  
  # Gamma distribution.
  mu <- with(crashes, sum(glance_prob * y) / sum(glance_prob))
  sigma2 <- with(crashes, sum(glance_prob * (y - mu)^2) / sum(glance_prob))
  theta0 <- c(shape = mu^2 / sigma2, rate = mu / sigma2) # Initial value.
  gamfit <- with(crashes, optim(theta0, function(par) wnll(par, dens = dgamma, y = y, w = w, p = glance_prob)))
  
  # Choose best fitting model.
  if ( gamfit$value < lnfit$value ) {
    fit <- gamfit
    fit$dist <- "gamma"
  } else {
    fit <- lnfit
    fit$dist <- "lognormal"
  }
  return(fit)
}


# Calculate sampling scheme.
calculate_sampling_scheme <- function(data, crit, fit) {
  
  if ( crit == "uniform" ) {
    
    pi <- rep(1, nrow(data))
    
  } else if ( crit == "prob" ) {
    
    pi <- with(data, glance_prob * sqrt(prob_positive))
    
  } else if ( crit == "mean" ) {
    
    pi <- with(data, glance_prob * sqrt(prob_positive) * yhat)
    
  } else if ( crit == "moments" ) {
    
    size <- with(data, yhat + yhat^2 + yhat^3 + yhat^4)
    pi <- with(data, glance_prob * sqrt(prob_positive) * size)
    
  } else if ( crit == "std_moments" ) {
    
    size <- with(data, yhat / sd(yhat) + yhat^2 / sd(yhat^2) + yhat^3 / sd(yhat^3) + yhat^4 / sd(yhat^4))
    pi <- with(data, glance_prob * sqrt(prob_positive) * size)    
  } else if ( crit == "nll" ) {
    
    print("Not implemented yet!")
    
  } else if ( crit == "KL" ) {
    
    print("Not implemented yet!")
    
  }
  
  return(pi / sum(pi))
  
}


# Add data-points with certain outcomes (no crash or max impact speed crash) 
# to labelled set, remove from unlabelled set.
add_certainty_outcomes <- function(new_sample, labelled, unlabelled) {
  
  for ( i in unique(new_sample$ID) ) { # Iterate over all cases.
    
    # Min and max impact speed for current case.
    labelled_i <- labelled %>% 
      filter(ID == i)
    ymin <- min(labelled_i$y)
    ymax <- max(labelled_i$y)
    
    # New data for current case.
    labelled_ij <- new_sample %>% 
      filter(ID == i)
    
    
    for ( j in 1:nrow(labelled_ij) ) { # Iterative over all labelled data points.
      
      newx <- labelled_ij[j, ]
      
      if ( newx$y == ymin ) { # Add certainty non-crashes.
        ix <- with(unlabelled, which(ID == i & before <= newx$before & after <= newx$after))
        
        add <- unlabelled %>% 
          filter(row_number() %in% ix) %>%
          mutate(y = ymin) %>% 
          dplyr::select(-yhat, -prob_positive)
        
        labelled <- labelled %>%
          add_row(add)
        
        if ( length(ix) > 0) {
          unlabelled <- unlabelled[-ix, ]
        }
        
      } else if ( newx$y == ymax ) { # Add certainty max impact speed crashes.
        
        ix <- with(unlabelled, which(ID == i & before >= newx$before & after >= newx$after))
        
        add <- unlabelled %>% 
          filter(row_number() %in% ix) %>%
          mutate(y = ymax) %>% 
          dplyr::select(-yhat, -prob_positive)
        
        labelled <- labelled %>%
          add_row(add)
        
        if ( length(ix) > 0) {
          unlabelled <- unlabelled[-ix, ]
        }
      }
    }
  }
  
  return(list(labelled = labelled, unlabelled = unlabelled))
  
}

active_learning <- function(data, optimizefactor = 'Impact_speed' ,niter = 1e2, bsize = 10, crit = "mean", plot = FALSE, plotit = 1:niter, fcount = 1) {
  # INPUT
  # data: input data set with variables 
  #   - 'after': glance duration after tauinv = 0.2 s.
  #   - 'before': (glance duration before tauinv = 0.2 s.
  #   - 't': total glance duration (s).
  #   - 'glance_prob': probability of glance.
  #   - 'ID': ID for specific case. 
  # optimizefactor = 'Impact_speed', 'Injury_reduction' or 'Speed_reduction'
  # niter: number of iterations.
  # bsize: number of datapoints to sample.
  # crit: optimisation criterion. Should be one of "uniform", "mean", "prob", "moments" or "std_moments".
  # plot: should plots be saved (TRUE/FALSE). 
  # plotit: iteration numbers for which plots will be generated.
  # fcount: starting index for figure numbers.
  #
  # OUTPUT: list of three datasets:
  #   - all: all 'labelled' observations (i.e. for which the outcome has been observed).
  #   - crashes: all generated crashes. 
  #   - noncrashes: all generated non-crashes.
  #   - figures stored in Output folder.
  
  
  # Start grid.
  # four corner points grid
  # grid <- tibble(after = c(0.1), before = dec$dec[1]) %>%
  #   add_row(after = c(0.1), before = dec$dec[length(dec$dec)]) %>%
  #   add_row(after = c(6.2), before = dec$dec[1]) %>%
  #   add_row(after = c(6.2), before = dec$dec[length(dec$dec)]) %>%
  #   mutate(selected = 1)
  # 3*4 grid 
  # grid <- tibble(after = c(0.1), before = dec$dec) %>%
  #   add_row(after = c(3.1), before = dec$dec) %>%
  #   add_row(after = c(6.2), before = dec$dec) %>%
  #   mutate(selected = 1)
  grid <- tibble(after = c(0.1), before = dec$dec) %>%
    add_row(after = c(1.1), before = dec$dec) %>%
    add_row(after = c(2.1), before = dec$dec) %>%
    add_row(after = c(3.1), before = dec$dec) %>%
    add_row(after = c(4.1), before = dec$dec) %>%
    add_row(after = c(5.1), before = dec$dec) %>%
    add_row(after = c(6.2), before = dec$dec) %>%
    mutate(selected = 1)
  # Labelled set.
  labelled <- data %>% 
    left_join(grid, by = c("after", "before")) %>%
    filter(selected == 1) %>% 
    mutate(y = get_y(ID, before, after,optimizefactor),
           w = 1)
  if(optimizefactor == 'Injury_reduction'){
    groundtruth_pick = df_with_y[df_with_y$R>0,]
    groundtruth <- data.frame(as.numeric(groundtruth_pick$R),groundtruth_pick$glance_prob,as.factor(rep('Ground truth',length(groundtruth_pick$R))))
  }
  else if(optimizefactor == 'Speed_reduction'){
    groundtruth_pick = df_with_y[df_with_y$dy>0,]
    groundtruth <- data.frame(as.numeric(groundtruth_pick$dy),groundtruth_pick$glance_prob,as.factor(rep('Ground truth',length(groundtruth_pick$dy))))
  }
  else if(optimizefactor == 'Impact_speed'){
    groundtruth_pick = df_with_y[df_with_y$y>0,]
    groundtruth <- data.frame(as.numeric(groundtruth_pick$y),groundtruth_pick$glance_prob,as.factor(rep('Ground truth',length(groundtruth_pick$y))))
  }
  colnames(groundtruth) <- c('y','glance_prob','group')
  
  # Unlabelled set.
  unlabelled <- data %>% 
    left_join(grid, by = c("after", "before")) %>%
    filter(is.na(selected)) %>% 
    mutate(w = 0,
           selected = 0,
           yhat = NA,
           prob_positive = NA)
  # Iterate
  new_sample <- labelled 
  k <- 1
  prediction_mse = c()
  for ( i in 1:niter ) {
    
    print(sprintf("Iteration %d", i))
    
    # Add data-points with certain outcomes (no crash or max impact speed crash) 
    # to labelled set, remove from unlabelled set.
    update <- add_certainty_outcomes(new_sample, labelled, unlabelled)
    labelled <- update$labelled
    unlabelled <- update$unlabelled
    crashes <- labelled %>% 
      filter(y > 0) %>% 
      mutate(w_final = glance_prob *w)
    
    sample_impact <- data.frame(crashes$y,crashes$w_final,as.factor(rep('sampling',length(crashes$y))))
    colnames(sample_impact) <- c('y','glance_prob','group')
    out_hist_impact = rbind(groundtruth,sample_impact)
    
    # First iteration: set all weights to 1 for labelled data points.
    if ( i == 1) {
      labelled$w <- 1
    }
    
    # Update predictions for cases with new data.
    for ( j in unique(new_sample$ID) ) {
      
      print(sprintf("Case = %s", j))
      
      # Update predictions.
      pred <- update_predictions(labelled %>% filter(ID == j), 
                                 unlabelled %>% filter(ID == j)) %>% 
        dplyr::select(ID, before, after, yhat, prob_positive)
      
      # Merge to unlabelled dataset.
      unlabelled %<>%
        left_join(pred, by = c("ID", "before", "after")) %>%
        mutate(yhat = ifelse(!is.na(yhat.y), yhat.y, yhat.x),
               prob_positive = ifelse(!is.na(prob_positive.y), prob_positive.y, prob_positive.x)) %>%
        dplyr::select(-yhat.x, -yhat.y, -prob_positive.x, -prob_positive.y)
      
    } # End for j in unique(new_sample$ID)
    
    
    # Fit model to impact speed distribution. Currently not used.
    #fit <- fitdist(labelled)
    
    # Calculate sampling probabilities. 
    pi <- calculate_sampling_scheme(unlabelled, crit, fit)
    
    # Error for unlabelled prediction
    check_error = unlabelled %>%
      mutate(y = get_y(ID, before, after,optimizefactor),
             selected = 0)
    e =  check_error$y - check_error$yhat
    prediction_mse[i] = sum(e^2)/length(e)
    error_prob = data.frame(e,check_error$glance_prob)
    colnames(error_prob) = c('e','glance_prob')
    
    # Plots.
    if ( plot & i %in% plotit ) {
      
      if ( length(unique(labelled$ID)) == 1 ) {
        if ( i == 1) {
          p1 <- ggplot(data = labelled %>% filter(selected == 1)) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            coord_equal() +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            expand_limits(y = 6.1) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "Deceleration [m/s^2]",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.6, "cm")) +
            ylim(-11, -3)                 +xlim(0, 6)
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "Deceleration [m/s^2]",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.6, "cm")) +             
            ylim(-11, -3)                 +xlim(0, 6) 
        } else {
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            geom_rect(data = new_sample, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05), fill = "firebrick") +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "Deceleration [m/s^2]",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.6, "cm")) +             
            ylim(-11, -3)                 +xlim(0, 6) 
          
        }
        
        p3 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = prob_positive)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y>0), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          expand_limits(y = 7) +
          coord_equal() +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Anticipated collision probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "Deceleration [m/s^2]",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = c(0, 0.925),
                legend.key.height = unit(0.3, "cm"),
                legend.key.width = unit(1.19, "cm")) +             
          ylim(-11, -3)                 +xlim(0, 6) 
        
        p4 <- ggplot(data = labelled) +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = yhat)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
          expand_limits(y = 7) +
          coord_equal() +
          expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
          labs(title = "",
               subtitle = "Anticipated impact speed (km/h)",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "Deceleration [m/s^2]",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = c(0, 0.925),
                legend.key.height = unit(0.3, "cm"),
                legend.key.width = unit(1.19, "cm")) +             
          ylim(-11, -3)                 +xlim(0, 6) 
        
        p5 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = pi)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05), fill = "grey40", colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          expand_limits(y = 7) +
          coord_equal() +
          labs(title = "",
               subtitle = "Sampling probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "Deceleration [m/s^2]",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = c(0, 0.925),
                legend.key.height = unit(0.3, "cm"),
                legend.key.width = unit(1.19, "cm")) +             
          ylim(-11, -3)                 +xlim(0, 6) 
        
        
        p6 = ggplot(out_hist_impact, aes(x = y, fill = group, weight = glance_prob)) +
          geom_histogram(bins = 30,alpha = 0.5, position = "identity")+
          labs(title = sprintf("Iteration %d", i),
               x = optimizefactor,
               y = "Weight",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm")) 
        
        if ( i == 1 ) {
          ggsave(sprintf("Output/fig%d.png", fcount), p1, dpi = 1000, width = 90, height = 90, unit = "mm")
          fcount <- fcount + 1 
        }
        ggsave(sprintf("Output/fig%d.png", fcount), p2, dpi = 1000, width = 90, height = 90, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), plot_grid(p3, p4, p5, ncol = 3, align = "vh", axis = "tblr"), 
               dpi = 1000, width = 270, height = 100, unit = "mm")
        fcount <- fcount + 1 
        
        ggsave(sprintf("Output/fig%d.png", fcount), p6, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        
      } else {
        
        ptsize <- 16
        ptsmall <- 12
        theme_set(theme_bw()) 
        theme_update(axis.text = element_text(size = ptsize, colour = "black", family = "sans"),
                     axis.line = element_line(colour = "black", size = 0.25), 
                     axis.ticks = element_line(colour = "black", size = 0.25), 
                     legend.key.width = unit(2, "cm"),
                     legend.key.height = unit(0.4, "cm"),
                     legend.margin = ggplot2::margin(t = -0.25, unit = 'cm'),
                     legend.spacing =  unit(0, "cm"),
                     legend.position = "bottom",
                     legend.text = element_text(size = ptsmall, colour = "black", family = "sans"),
                     legend.title = element_text(size = ptsmall, colour = "black", family = "sans"),
                     strip.background.x = element_blank(),
                     panel.grid = element_blank(),
                     plot.subtitle = element_text(size = ptsmall, colour = "black", family = "sans", face = "plain", hjust = 0),
                     plot.title = element_text(size = ptsize, colour = "black", family = "sans", face = "plain", hjust = 0),
                     text = element_text(size = ptsize, colour = "black", family = "sans"))
        
        if ( i == 1) {
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            facet_wrap(~ID, ncol =6, nrow = 8, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "Deceleration [m/s^2]",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.5, "cm"),
                  legend.key.width = unit(2, "cm")) +             
            ylim(-11, -3)                 +xlim(0, 6) 
        } else {
          
          p2 <- ggplot(data = labelled) +
            geom_rect(aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y)) +
            geom_rect(data = new_sample, aes(xmin = after - 0.1, xmax = after + 0.1, ymin = before - 0.1, ymax = before + 0.1), fill = "firebrick") +
            scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
            facet_wrap(~ID, ncol =6, nrow = 8, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
            coord_equal() +
            expand_limits(y = 6.1) +
            expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
            labs(title = sprintf("Iteration %d", i),
                 x = "EOFF after tauinv = 0.2 (s)",
                 y = "Deceleration [m/s^2]",
                 fill = "Impact speed (km/h)") +
            theme(legend.direction = "horizontal",
                  legend.justification = 0.5,
                  legend.position = "bottom",
                  legend.key.height = unit(0.5, "cm"),
                  legend.key.width = unit(2, "cm")) +             
            ylim(-11, -3)                 +xlim(0, 6) 
          
        }
        
        p3 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = prob_positive)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y>0), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          facet_wrap(~ID, ncol =6, nrow = 8, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
          coord_equal() +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Anticipated collision probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "Deceleration [m/s^2]",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm")) +             
          ylim(-11, -3)                 +xlim(0, 6) 
        
        p4 <- ggplot(data = labelled) +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = yhat)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = y), colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", labels = scales::number_format(digits = 1)) +
          facet_wrap(~ID, ncol =6, nrow = 8, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
          coord_equal() +
          expand_limits(fill = c(0, ceiling(2 * max(labelled$y)) / 2)) +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Anticipated impact speed (km/h)",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "Deceleration [m/s^2]",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm")) +             
          ylim(-11, -3)                 +xlim(0, 6) 
        
        p5 <- ggplot() +
          geom_rect(data = unlabelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05, fill = pi)) +
          geom_rect(data = labelled, aes(xmin = after - 0.05, xmax = after + 0.05, ymin = before - 0.05, ymax = before + 0.05), fill = "grey40", colour = "black", size = 0.01) +
          scale_fill_continuous(type = "viridis", trans = "log10", labels = scales::scientific_format(scale = 1)) +
          facet_wrap(~ID, ncol =6, nrow = 8, labeller = labeller(ID = function(x) sprintf("ID = %s", x))) + 
          coord_equal() +
          labs(title = sprintf("Iteration %d", i),
               subtitle = "Sampling probability",
               x = "EOFF after tauinv = 0.2 (s)",
               y = "Deceleration [m/s^2]",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm")) +             
          ylim(-11, -3)                 +xlim(0, 6) 
        
        
        p6 = ggplot(out_hist_impact, aes(x = y, fill = group, weight = glance_prob)) +
          geom_histogram(bins = 30,alpha = 0.5, position = "identity")+
          labs(title = sprintf("Iteration %d", i),
               x = optimizefactor,
               y = "Weight",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm")) 
        # P7 probably not really needed, and instead MSE for the unlabelled predicted error maybe more relevant
        p7 = ggplot(error_prob, aes(x = e, weight = glance_prob)) +
          geom_histogram(bins = 30,alpha = 0.5, position = "identity")+
          labs(title = sprintf("Iteration %d", i),
               x = "Estimation error",
               y = "Weight",
               fill = NULL) +
          theme(legend.direction = "horizontal",
                legend.justification = -0.025,
                legend.position = "top",
                legend.key.height = unit(0.5, "cm"),
                legend.key.width = unit(2, "cm")) 
        
        ggsave(sprintf("Output/fig%d.png", fcount), p2, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p3, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p4, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p5, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p6, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1 
        ggsave(sprintf("Output/fig%d.png", fcount), p7, dpi = 1000, width = 270, height = 270, unit = "mm")
        fcount <- fcount + 1
      }
    }
    # Sample new observations.
    ix <- as.numeric(rmultinom(n = 1, size = bsize, prob = pi))
    new_wt <- ix / (bsize * pi)
    
    # Get data for sampled observations.
    new_sample <- unlabelled %>% 
      mutate(new_wt = new_wt) %>% 
      filter(new_wt > 0) %>% 
      mutate(y = get_y(ID, before, after,optimizefactor),
             selected = 1) %>% 
      dplyr::select(-prob_positive, -yhat)
    
    # Update labelled and unlabelled sets.
    labelled <- labelled %>%
      mutate(new_wt = 1) %>% # Re-query labelled data points with probability 1. 
      add_row(new_sample) %>%
      mutate(w = w + (new_wt - w) / k) %>%
      dplyr::select(-new_wt)
    
    unlabelled %<>%
      mutate(new_wt = new_wt) %>% 
      filter(new_wt <= 0) %>% 
      dplyr::select(-new_wt)
    
    # Increase counter if at least one new crash has been generated.
    k <- k + (any(new_sample$y > 0))
    
  } # End active learning.
  
  labelled <- labelled 
  
  crashes <- labelled %>% 
    filter(y > 0) %>% 
    mutate(w_final = glance_prob *w)
  
  noncrashes <- labelled %>% 
    filter(y == 0)
  # could include MSE for labelled data here as well
  MSE <- prediction_mse
  return(list(all = labelled, crashes = crashes, noncrashes = noncrashes,MSE = MSE))
  
}





