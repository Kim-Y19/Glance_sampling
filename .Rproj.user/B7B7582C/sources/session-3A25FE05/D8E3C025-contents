update_predictions <- function(labelled, unlabelled, target = NULL, verbose = FALSE, plot = FALSE) {

  defaultW <- getOption("warn")
  
  # Calculate maximal impact speed per case.
  maximpact0 <- labelled %>%
    group_by(caseID) %>%
    summarise(maximpact0 = max(impact_speed0, na.rm = TRUE), .groups = "keep") %>%
    ungroup() %>%
    dplyr::select(caseID, maximpact0)

  labelled %<>%
    left_join(maximpact0, by = "caseID") %>% 
    mutate(sampling_weight = ifelse(sampling_weight == 0, 1, sampling_weight), # Set sampling weight of certainty-selections to unity.
           final_weight = sampling_weight * eoff_acc_prob)
  labelled$caseID <- factor(labelled$caseID)
  
  unlabelled %<>%
    left_join(maximpact0, by = "caseID") 
  unlabelled$caseID <- factor(unlabelled$caseID)
  
  crashes <- labelled %>%
    filter(impact_speed0 > 0)
  

  # Hyper-parameter tuning grid for random forest regression and classification.
  regGrid <- crossing(splitrule = "variance", 
                      min.node.size = 1:20,
                      mtry = 1:3)
  
  classGrid <- crossing(splitrule = "gini", 
                        min.node.size = 1:20,
                        mtry = 1:3)
  
  
  # Estimate baseline collision probability. ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- classGrid[sample(1:nrow(classGrid), 3), ]
  rf <- safe_caret_train(factor(impact_speed0 > 0, labels = paste0("Y", 0:1)) ~ eoff + acc + maximpact0, 
                         data = labelled,
                         method = "ranger",
                         num.trees = 100,
                         tuneGrid = as.data.frame(grid),
                         trControl = trainControl(method = "cv",
                                                  number = 5,
                                                  classProbs = TRUE))
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    p0_train <- predict(rf, labelled, type = "prob")$Y1
    p0_train[p0_train <= 0] <- min(p0_train[p0_train > 0]) # Avoid zero probabilities.
    
    p0_test <- predict(rf, unlabelled, type = "prob")$Y1
    p0_test[p0_test <= 0] <- min(p0_test[p0_test > 0]) # Avoid zero probabilities.
    
    # Accuracy.
    ix <- with(rf$results, which(min.node.size == rf$finalModel$min.node.size & mtry == rf$finalModel$mtry))
    p0_acc <- rf$results[ix, "Accuracy"]
    
  } else { # If unable to fit model: set to constant.
    
    p0_train <- 1
    p0_test <- 1
    p0_acc <- NA
    
  } # End !is.null(rf).
  
  
  # Predict baseline impact speed. ----
  
  # Train random forest.  
  options(warn = -1)
  grid <- regGrid[sample(1:nrow(regGrid), 3), ]
  rf <- safe_caret_train(impact_speed0 ~ eoff + acc + maximpact0, 
                         data = crashes,
                         method = "ranger",
                         num.trees = 100,
                         tuneGrid = as.data.frame(grid),
                         trControl = trainControl(method = "cv",
                                                  number = 5))
  options(warn = defaultW)
  
  if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
    
    # Prediction on labelled and unlabelled data.
    xhat_train <- predict(rf, crashes)
    xhat_test <- predict(rf, unlabelled)

    # Root mean squared prediction error and prediction R-squared.
    rmse_xhat <- sqrt(rf$finalModel$prediction.error) 
    r2_xhat <- rf$finalModel$r.squared
    
  } else { # If unable to fit model: set to constant.
    
    xhat_train <- 1
    xhat_test <- 1
    rmse_xhat <- NA
    r2_xhat <- NA
    
  }
  
  crashes$impact_speed0_pred <- xhat_train
  unlabelled$impact_speed0_pred <- xhat_test
  
 
  # Predict impact speed reduction ----
  if ( target == "impact speed reduction" ) {
    
    # Train random forest.  
    options(warn = -1)
    grid <- regGrid[sample(1:nrow(regGrid), 3), ]
    rf <- safe_caret_train(impact_speed_reduction ~ eoff + acc + impact_speed0_pred, 
                           data = crashes,
                           method = "ranger",
                           num.trees = 100,
                           tuneGrid = as.data.frame(grid),
                           trControl = trainControl(method = "cv",
                                                    number = 5))
    options(warn = defaultW)
    
    if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
      
      # Prediction on labelled and unlabelled data.
      yhat_train <- predict(rf, crashes)
      yhat_test <- predict(rf, unlabelled)
      
      # Root mean squared prediction error and prediction R-squared.
      rmse_yhat <- sqrt(rf$finalModel$prediction.error) 
      r2_yhat <- rf$finalModel$r.squared
      
    } else { # If unable to fit model: set to constant.
      
      yhat_train <- 1
      yhat_test <- 1
      rmse_yhat <- NA
      r2_yhat <- NA
      
    }
  } else { # If target not impact speed reduction: don't fit model, set to constant.
    
    yhat_train <- 1
    yhat_test <- 1
    rmse_yhat <- NA
    r2_yhat <- NA
    
  }
  
  
  # Predict injury risk reduction. ----
  if ( target == "injury risk reduction" ) {
    
    # Train random forest.  
    options(warn = -1)
    grid <- regGrid[sample(1:nrow(regGrid), 3), ]
    rf <- safe_caret_train(injury_risk_reduction ~ eoff + acc + impact_speed0_pred, 
                           data = crashes,
                           method = "ranger",
                           num.trees = 100,
                           respect.unordered.factors = "partition",
                           tuneGrid = as.data.frame(grid),
                           trControl = trainControl(method = "cv",
                                                    number = 5))
    options(warn = defaultW)
    
    if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
      
      # Prediction on labelled and unlabelled data.
      zhat_train <- predict(rf, crashes)
      zhat_test <- predict(rf, unlabelled)
      
      # Root mean squared prediction error and prediction R-squared.
      rmse_zhat <- sqrt(rf$finalModel$prediction.error) 
      r2_zhat <- rf$finalModel$r.squared
      
    } else { # If unable to fit model: set to constant.
      
      zhat_train <- 1
      zhat_test <- 1
      rmse_zhat <- NA
      r2_zhat <- NA
      
    }
  } else { # If target not injury risk reduction: don't fit model, set to constant.
    
    zhat_train <- 1
    zhat_test <- 1
    rmse_zhat <- NA
    r2_zhat <- NA
    
  }
  
  
  # Estimate counter-measure collision probability. ----
  if ( target == "crash avoidance" ) {
    
    # Train random forest.  
    options(warn = -1)
    grid <- classGrid[sample(1:nrow(classGrid), 3), ]
    rf <- safe_caret_train(factor(impact_speed1 > 0, labels = paste0("Y", 0:1)) ~ eoff + acc + impact_speed0_pred, 
                           data = crashes,
                           method = "ranger",
                           num.trees = 100,
                           tuneGrid = as.data.frame(grid),
                           trControl = trainControl(method = "cv",
                                                    number = 5,
                                                    classProbs = TRUE))
    options(warn = defaultW)
    
    if ( !is.null(rf) ) { # If able to fit model: calculate predictions.
      
      # Prediction on labelled and unlabelled data.
      p1_train <- predict(rf, crashes, type = "prob")$Y1
      p1_train[p1_train <= 0] <- min(p1_train[p1_train > 0]) # Avoid zero probabilities.
      
      p1_test <- predict(rf, unlabelled, type = "prob")$Y1
      p1_test[p1_test <= 0] <- min(p1_test[p1_test > 0]) # Avoid zero probabilities.
      
      # Accuracy.
      ix <- with(rf$results, which(min.node.size == rf$finalModel$min.node.size & mtry == rf$finalModel$mtry))
      p1_acc <- rf$results[ix, "Accuracy"]
      
    } else { # If unable to fit model: set to constant.
      
      p1_train <- 1
      p1_test <- 1
      p1_acc <- NA
      
    } # End !is.null(rf).
  } else { # If target not crash avoidance: don't fit model, set to constant.
    
    p1_train <- 1
    p1_test <- 1
    p1_acc <- NA
    
  }
  
  
  # Combine to calculate predictions on labelled  data. 
  labelled %<>% 
    mutate(collision_prob0_pred = p0_train)
  
  crashes %<>%
    mutate(impact_speed0_pred = xhat_train, 
           impact_speed_reduction_pred = yhat_train, 
           injury_risk_reduction_pred = zhat_train, 
           collision_prob1_pred = p1_train) 
  
   # Print.
  if ( verbose ) {
    
    cat(sprintf("Out-of-bag R-squared:
Baseline impact speed = %.2f
Impact speed reduction = %.2f
Injury risk reduction = %.2f.

Out-of-bag Accuracy:
Baseline crash probability = %.2f.
Counter-meature crash probability = %.2f.
                ", 
                r2_xhat, 
                r2_yhat,
                r2_zhat,
                p0_acc,
                p1_acc))
    cat("\n")
    
  }
  
  
  # Add logic.
  p0_test <- pmax(p0_test, unlabelled$crash0, na.rm = TRUE)  # Certainty crashes.
  p0_test <- pmin(p0_test, 1 - unlabelled$non_crash0, na.rm = TRUE)  # Certainty non-crashes.
  p1_test <- pmax(p1_test, unlabelled$crash1, na.rm = TRUE)  # Certainty crashes.
  p1_test <- pmin(p1_test, 1 - unlabelled$non_crash1, na.rm = TRUE)  # Certainty non-crashes.
  xhat_test <- with(unlabelled, ifelse(!is.na(max_impact0) & max_impact0 == 1, maximpact0, xhat_test)) # Certainty maximal impact speed crashes. 
  xhat_test <- pmin(unlabelled$maximpact0, xhat_test) # Predictions should not exceed known maximum impact speed.
  
  
  # Plot.
  if ( plot ) {
    
    par(mfrow = c(2, 2))
    plot(labelled$collision_prob0_pred, labelled$impact_speed0 > 0, col = labelled$caseID, bty = "l")
    plot(crashes$impact_speed0_pred, crashes$impact_speed0, bty = "l", col = crashes$caseID, xlim = range(crashes$impact_speed0))
    abline(0, 1)
    plot(crashes$eoff, crashes$impact_speed0, bty = "l", col = crashes$caseID)
    plot(crashes$eoff, crashes$impact_speed0_pred, bty = "l", col = crashes$caseID, ylim = range(crashes$impact_speed0))
    
    plot(p0_test, unlabelled$impact_speed0 > 0, bty = "l", col = unlabelled$caseID)
    abline(lm(unlabelled$impact_speed0 > 0 ~ p0_test))  
    plot(xhat_test, unlabelled$impact_speed0, bty = "l", col = unlabelled$caseID, xlim = range(unlabelled$impact_speed0))
    abline(lm(unlabelled$impact_speed0~xhat_test), col = "red", lty = 2)
    abline(0, 1, lwd = 2)
    plot(unlabelled$eoff, unlabelled$impact_speed0, bty = "l", col = unlabelled$caseID)
    plot(unlabelled$eoff, xhat_test, bty = "l", col = unlabelled$caseID, ylim = range(unlabelled$impact_speed0))
    par(mfrow = c(1, 1))
    
    if ( target == "impact speed reduction" ) {
      
      par(mfrow = c(1, 3))
      plot(crashes$impact_speed_reduction_pred, crashes$impact_speed_reduction, bty = "l", col = crashes$caseID, xlim = range(crashes$impact_speed_reduction))
      abline(0, 1)
      plot(crashes$eoff, crashes$impact_speed_reduction, bty = "l", col = crashes$caseID)
      plot(crashes$eoff, crashes$impact_speed_reduction_pred, bty = "l", col = crashes$caseID, ylim = range(crashes$impact_speed_reduction))
      
      plot(yhat_test, unlabelled$impact_speed_reduction, bty = "l", col = unlabelled$caseID, xlim = range(unlabelled$impact_speed_reduction))
      abline(lm(unlabelled$impact_speed_reduction~yhat_test), col = "red", lty = 2)
      abline(0, 1, lwd = 2)
      plot(unlabelled$eoff, unlabelled$impact_speed_reduction, bty = "l", col = unlabelled$caseID)
      plot(unlabelled$eoff, yhat_test, bty = "l", col = unlabelled$caseID, ylim = range(unlabelled$impact_speed_reduction))
      par(mfrow = c(1, 1))
      
    }
    
    if (target == "injury risk reduction" ) {
      
      par(mfrow = c(1, 3))
      plot(crashes$injury_risk_reduction_pred, crashes$injury_risk_reduction, bty = "l", col = crashes$caseID, xlim = range(crashes$injury_risk_reduction))
      abline(0, 1)
      plot(crashes$eoff, crashes$injury_risk_reduction, bty = "l", col = crashes$caseID)
      plot(crashes$eoff, crashes$injury_risk_reduction_pred, bty = "l", col = crashes$caseID, ylim = range(crashes$injury_risk_reduction))
      
      plot(zhat_test, unlabelled$injury_risk_reduction, bty = "l", col = unlabelled$caseID, xlim = range(unlabelled$injury_risk_reduction))
      abline(lm(unlabelled$injury_risk_reduction~zhat_test), col = "red", lty = 2)
      abline(0, 1, lwd = 2)
      plot(unlabelled$eoff, unlabelled$injury_risk_reduction, bty = "l", col = unlabelled$caseID)
      plot(unlabelled$eoff, zhat_test, bty = "l", col = unlabelled$caseID, ylim = range(unlabelled$injury_risk_reduction))
      par(mfrow = c(1, 1))
      
    }
    
    if (target == "crash avoidance") {
      par(mfrow = c(1, 2))
      plot(crashes$collision_prob1_pred, crashes$impact_speed1 > 0, col = crashes$caseID, bty = "l")
      plot(p1_test, unlabelled$impact_speed1 > 0, bty = "l", col = unlabelled$caseID)
      abline(lm(unlabelled$impact_speed1 > 0 ~ p1_test))
      par(mfrow = c(1, 1))
      
    }
    
  } # End plot.
  
  
  # Return.
  rmse_log_xhat <- with(crashes, sd(log(impact_speed0) - log(impact_speed0_pred)))
  return(list(collision_prob0 = p0_test,
              collision_prob1 = p1_test,
              impact_speed0_pred = xhat_test,
              impact_speed_reduction_pred = yhat_test,
              injury_risk_reduction_pred = zhat_test,
              rmse_log_impact_speed0 = rmse_log_xhat,
              rmse_impact_speed_reduction = rmse_yhat,
              rmse_injury_risk_reduction = rmse_zhat,
              r2_impact_speed0 = r2_xhat,
              r2_impact_speed_reduction = r2_yhat,
              r2_injury_risk_reduction = r2_zhat,
              accuracy_crash0 = p0_acc,
              accuracy_crash1 = p1_acc))
  
}